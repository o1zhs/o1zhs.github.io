<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="The personal website of 张浩森"><title>Linux下利用信号量函数和共享内存函数和C语言实现生产者消费者问题 | Abigale</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Abigale</a><span class="subtitle">The personal website of 张浩森</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Linux下利用信号量函数和共享内存函数和C语言实现生产者消费者问题</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2018-01-24</div></div></div><article><div class="container post"><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>此问题是操作系统中的一个经典的同步异步问题，是我们操作系统课程中非常重要的一部分。实验要求我们用C语言在Linux操作系统下利用信号量函数和共享内存函数实现经典的生产者消费者问题。也借此把所学知识记录下来。实验要求如下：</p>
<p>在Linux操作系统下用C实现经典同步问题:生产者—消费者，具体要求如下: </p>
<p>（1）一个大小为10的缓冲区，初始状态为空。</p>
<p>（2）2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。</p>
<p>（3）2个生产者，随机等待一段时间，往缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。</p>
<p>（4）当前只能有一个进程对这个缓冲区进行操作 。</p>
<p>（5）缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10。</p>
<p>（6）利用随机函数rand()得到A~Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中。</p>
<p>（7）使用shmget()系统调用实现共享主存段的创建，shmget()返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。</p>
<p>（8）信号量的建立采用semget()函数，同时建立信号量的 数量。在信号量建立后，调用semctl()对信号量进行初始2化 ，例如本实验中，可以建立两个信号量SEM_EMPTY、 SEM_FULL，初始化时设置SEM_EMPTY为10，SEM_FULL 为0。使用操 作信号的函数semop()做排除式操作，使用这个 函数防止对共享内存的同时操作。对共享内存操作完毕后采用shmctl()函数撤销共享内存段。</p>
<p>（9）使用循环，创建2个生产者以及2个消费者，采用函数 fork()创建一个新的进程。</p>
<p>（10）一个进程的一次操作完成后，采用函数fflush()刷新缓冲区。</p>
<p>（11）程序最后使用semctl()函数释放内存。</p>
<h3 id="二、生产者消费者问题"><a href="#二、生产者消费者问题" class="headerlink" title="二、生产者消费者问题"></a>二、生产者消费者问题</h3><p>生产者和消费者问题是多个相互合作的进程之间的一种抽象。生产者和消费者之间的关系:</p>
<ol>
<li>对缓冲区的访问是互斥的。由于两者都会修改缓冲区，因此，一方修改缓冲区时，另一方不能修改，这就是互斥。</li>
<li>一方的行为影响另一方。缓冲区不空，才能消费，何时不空？生产了就不空；缓冲区满，就不能生产，何时不满？消费了就不满。这是同步关系。</li>
</ol>
<p>为了描述这种关系，一方面，使用共享内存代表缓冲区；另一方面，使用互斥信号量 控制对缓冲区的访问，使用同步信号量描述两者的依赖关系。</p>
<h3 id="三、信号量"><a href="#三、信号量" class="headerlink" title="三、信号量"></a>三、信号量</h3><p>抽象的来讲，信号量（signal)的特性如下：信号量是一个非负整数，所有通过它的<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>/进程都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。在通用术语上我们将此两种操作成为P、V操作。而操作的对象就是信号量（signal)，用来实现线程/进程的同步、异步和互斥。</p>
<h3 id="四、共享内存函数"><a href="#四、共享内存函数" class="headerlink" title="四、共享内存函数"></a>四、共享内存函数</h3><p>共享内存函数由shmget、shmat、shmdt、shmctl四个函数组成。下面列出了这四个函数的函数原型及其具体说明。</p>
<h4 id="1-shmget函数原型"><a href="#1-shmget函数原型" class="headerlink" title="1.   shmget函数原型"></a>1.   shmget函数原型</h4><p>shmget(得到一个共享内存标识符或创建一个共享内存对象)</p>
<h5 id="所需头文件："><a href="#所需头文件：" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/ipc.h&gt;</code></p>
<p><code>#include &lt;sys/shm.h&gt;</code></p>
<h5 id="函数说明："><a href="#函数说明：" class="headerlink" title="函数说明："></a>函数说明：</h5><p>得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符</p>
<h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int shmget(key_t key, size_t size, int shmflg)</p>
<h5 id="函数传入值："><a href="#函数传入值：" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>key：</p>
<p>（1）0(IPC_PRIVATE)：会建立新共享内存对象。</p>
<p>（2）大于0的32位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值。</p>
<p>size：</p>
<p>（1）大于0的整数：新建的共享内存大小，以字节为单位。</p>
<p>（2）0：只获取共享内存时指定为0。</p>
<p>shmflg：</p>
<p>（1）0：取共享内存标识符，若不存在则函数会报错。</p>
<p>（2）IPC_CREAT：当shmflg&amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。</p>
<p>（3）IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错。</p>
<h5 id="函数返回值："><a href="#函数返回值：" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：返回共享内存的标识符。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="附加说明："><a href="#附加说明：" class="headerlink" title="附加说明："></a>附加说明：</h5><p>上述shmflg参数为模式标志参数，使用时需要与IPC对象存取权限（如0600表示用户可以读写改内存）进行|运算来确定信号量集的存取权限 。</p>
<h5 id="错误代码："><a href="#错误代码：" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）EINVAL：参数size小于SHMMIN或大于SHMMAX 。</p>
<p>（2）EEXIST：预建立key所指的共享内存，但已经存在 。</p>
<p>（3）EIDRM：参数key所指的共享内存已经删除 。</p>
<p>（4）ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)。</p>
<p>（5）ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位 。</p>
<p>（6）EACCES：没有权限 。</p>
<p>（7）ENOMEM：核心内存不足。</p>
<h5 id="附加说明：-1"><a href="#附加说明：-1" class="headerlink" title="附加说明："></a>附加说明：</h5><p>在Linux环境中，对开始申请的共享内存空间进行了初始化，初始值为0x00。</p>
<p>如果用shmget创建了一个新的消息队列对象时，则shmid_ds结构成员变量的值设置如下：</p>
<p>shm_lpid、shm_nattach、shm_atime、shm_dtime设置为0。</p>
<p>msg_ctime设置为当前时间。</p>
<p>shm_segsz设成创建共享内存的大小。</p>
<p>shmflg的读写权限放在shm_perm.mode中。</p>
<p>shm_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID。</p>
<h4 id="2-shmat函数原型"><a href="#2-shmat函数原型" class="headerlink" title="2.   shmat函数原型"></a>2.   shmat函数原型</h4><p>shmat(把共享内存区对象映射到调用进程的地址空间)</p>
<h5 id="所需头文件：-1"><a href="#所需头文件：-1" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/shm.h&gt;</code></p>
<h5 id="函数说明：-1"><a href="#函数说明：-1" class="headerlink" title="函数说明："></a>函数说明：</h5><p>连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。</p>
<h5 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h5><p>void <em>shmat(int shmid, const void </em>shmaddr, int shmflg)</p>
<h5 id="函数传入值：-1"><a href="#函数传入值：-1" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>msqid：共享内存标识符。</p>
<p>shmaddr：指定共享内存出现在进程内存地址的什么位置，直接指定为NULL让内核自己决定一个合适的地址位置。</p>
<p>shmflg：SHM_RDONLY：为只读模式，其他为读写模式。</p>
<h5 id="函数返回值：-1"><a href="#函数返回值：-1" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：附加好的共享内存地址。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="附加说明：-2"><a href="#附加说明：-2" class="headerlink" title="附加说明："></a>附加说明：</h5><p>fork后子进程继承已连接的共享内存地址。exec后该子进程与已连接的共享内存地址自动脱离(detach)。进程结束后，已连接的共享内存地址会自动脱离(detach)。</p>
<h5 id="错误代码：-1"><a href="#错误代码：-1" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）EACCES：无权限以指定方式连接共享内存。</p>
<p>（2）EINVAL：无效的参数shmid或shmaddr。</p>
<p>（3）ENOMEM：核心内存不足。</p>
<h4 id="3-shmdt函数原型"><a href="#3-shmdt函数原型" class="headerlink" title="3.   shmdt函数原型"></a>3.   shmdt函数原型</h4><p>shmat(断开共享内存连接)</p>
<h5 id="所需头文件：-2"><a href="#所需头文件：-2" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/shm.h&gt;</code></p>
<h5 id="函数说明：-2"><a href="#函数说明：-2" class="headerlink" title="函数说明："></a>函数说明：</h5><p>与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存。</p>
<h5 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int shmdt(const void *shmaddr)</p>
<h5 id="函数传入值：-2"><a href="#函数传入值：-2" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>shmaddr：连接的共享内存的起始地址。</p>
<h5 id="函数返回值：-2"><a href="#函数返回值：-2" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：0。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="附加说明：-3"><a href="#附加说明：-3" class="headerlink" title="附加说明："></a>附加说明：</h5><p>本函数调用并不删除所指定的共享内存区，而只是将先前用shmat函数连接（attach）好的共享内存脱离（detach）目前的进程。</p>
<h5 id="错误代码：-2"><a href="#错误代码：-2" class="headerlink" title="错误代码："></a>错误代码：</h5><p>EINVAL：无效的参数shmaddr。</p>
<h4 id="4-shmctl函数原型"><a href="#4-shmctl函数原型" class="headerlink" title="4.   shmctl函数原型"></a>4.   shmctl函数原型</h4><p>shmctl(共享内存管理)</p>
<h5 id="所需头文件：-3"><a href="#所需头文件：-3" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/shm.h&gt;</code></p>
<h5 id="函数说明：-3"><a href="#函数说明：-3" class="headerlink" title="函数说明："></a>函数说明：</h5><p>完成对共享内存的控制</p>
<h5 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf)</p>
<h5 id="函数传入值：-3"><a href="#函数传入值：-3" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>msqid：共享内存标识符</p>
<p>cmd:</p>
<p>（1）IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>（2）IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内 。</p>
<p>（3）IPC_RMID：删除这片共享内存。</p>
<p>buf：共享内存管理结构体。具体说明参见共享内存内核结构定义部分</p>
<h5 id="函数返回值：-3"><a href="#函数返回值：-3" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：0。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="错误代码：-3"><a href="#错误代码：-3" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）EACCESS：参数cmd为IPC_STAT，确无权限读取该共享内存。</p>
<p>（2）EFAULT：参数buf指向无效的内存地址。</p>
<p>（3）EIDRM：标识符为msqid的共享内存已被删除。</p>
<p>（4）EINVAL：无效的参数cmd或shmid。</p>
<p>（5）EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行 。</p>
<h3 id="四、信号量函数"><a href="#四、信号量函数" class="headerlink" title="四、信号量函数"></a>四、信号量函数</h3><p>信号量函数由semget、semop、semctl三个函数组成。下面列出了这三个函数的函数原型及具体说明。</p>
<h4 id="1-semget函数原型"><a href="#1-semget函数原型" class="headerlink" title="1.   semget函数原型"></a>1.   semget函数原型</h4><p>semget(得到一个信号量集标识符或创建一个信号量集对象)</p>
<h5 id="所需头文件：-4"><a href="#所需头文件：-4" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/ipc.h&gt;</code></p>
<p><code>#include &lt;sys/sem.h&gt;</code></p>
<h5 id="函数说明：-4"><a href="#函数说明：-4" class="headerlink" title="函数说明："></a>函数说明：</h5><p>得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符。</p>
<h5 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int semget(key_t key, int nsems, int semflg)</p>
<h5 id="函数传入值：-4"><a href="#函数传入值：-4" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>key：</p>
<p>（1）0(IPC_PRIVATE)：会建立新信号量集对象。</p>
<p>（2）大于0的32位整数：视参数semflg来确定操作，通常要求此值来源于ftok返回的IPC键值。</p>
<p>nsems：创建信号量集中信号量的个数，该参数只在创建信号量集时有效。</p>
<p>semfl：</p>
<p>（1）0：取信号量集标识符，若不存在则函数会报错。</p>
<p>（2）IPC_CREAT：当semflg&amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的信号量集，则新建一个信号量集；如果存在这样的信号量集，返回此信号量集的标识符。</p>
<p>（3）IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的信号量集，则新建一个消息队列；如果存在这样的信号量集则报错。</p>
<h5 id="函数返回值：-4"><a href="#函数返回值：-4" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：返回信号量集的标识符。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="附加说明：-4"><a href="#附加说明：-4" class="headerlink" title="附加说明："></a>附加说明：</h5><p>上述semflg参数为模式标志参数，使用时需要与IPC对象存取权限（如0600如共享内存函数）进行|运算来确定信号量集的存取权限 。</p>
<h5 id="错误代码：-4"><a href="#错误代码：-4" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）EACCESS：没有权限。</p>
<p>（2）EEXIST：信号量集已经存在，无法创建。</p>
<p>（3）EIDRM：信号量集已经删除。</p>
<p>（4）ENOENT：信号量集不存在，同时semflg没有设置IPC_CREAT标志。</p>
<p>（5）ENOMEM：没有足够的内存创建新的信号量集。</p>
<p>（6）ENOSPC：超出限制。</p>
<p>如果用semget创建了一个新的信号量集对象时，则semid_ds结构成员变量的值设置如下：</p>
<p>​        sem_otime设置为0。</p>
<p>​        sem_ctime设置为当前时间。</p>
<p>​        msg_qbytes设成系统的限制值。</p>
<p>​        sem_nsems设置为nsems参数的数值。</p>
<p>​        semflg的读写权限写入sem_perm.mode中。</p>
<p>​        sem_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID。</p>
<h4 id="2-semop函数原型"><a href="#2-semop函数原型" class="headerlink" title="2.   semop函数原型"></a>2.   semop函数原型</h4><p>semop(完成对信号量的P操作或V操作)</p>
<h5 id="所需头文件：-5"><a href="#所需头文件：-5" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/ipc.h&gt;</code></p>
<p><code>#include &lt;sys/sem.h&gt;</code></p>
<h5 id="函数说明：-5"><a href="#函数说明：-5" class="headerlink" title="函数说明："></a>函数说明：</h5><p>对信号量集标识符为semid中的一个或多个信号量进行P操作或V操作。</p>
<h5 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int semop(int semid, struct sembuf *sops, unsigned nsops)</p>
<h5 id="函数传入值：-5"><a href="#函数传入值：-5" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>semid：信号量集标识符。</p>
<p>sops：指向进行操作的信号量集结构体数组的首地址，此结构的具体说明如下：</p>
<p>struct sembuf {</p>
<p>​    short semnum; /<em>信号量集合中的信号量编号，0代表第1个信号量</em>/</p>
<p>​    short val;/<em>若val&gt;0进行V操作信号量值加val，表示进程释放控制的资源 </em>/</p>
<p>/<em>若val&lt;0进行P操作信号量值减val，若(semval-val)&lt;0（semval为该信号量值），则调用进程阻塞，直到资源可用；若设置IPC_NOWAIT不会睡眠，进程直接返回EAGAIN错误</em>/ </p>
<p>  /<em>若val==0时阻塞等待信号量为0，调用进程进入睡眠状态，直到信号值为0；若设置IPC_NOWAIT，进程不会睡眠，直接返回EAGAIN错误</em>/</p>
<p>​    short flag;  /<em>0 设置信号量的默认操作</em>/</p>
<p>/<em>IPC_NOWAIT设置信号量操作不等待</em>/</p>
<p>/<em>SEM_UNDO 选项会让内核记录一个与调用进程相关的UNDO记录，如果该进程崩溃，则根据这个进程的UNDO记录自动恢复相应信号量的计数值</em>/</p>
<p>  }; </p>
<p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p>
<h5 id="函数返回值：-5"><a href="#函数返回值：-5" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：返回信号量集的标识符。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="错误代码：-5"><a href="#错误代码：-5" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）E2BIG：一次对信号量个数的操作超过了系统限制。</p>
<p>（2）EACCESS：权限不够。</p>
<p>（3）EAGAIN：使用了IPC_NOWAIT，但操作不能继续进行。</p>
<p>（4）EFAULT：sops指向的地址无效。</p>
<p>（5）EIDRM：信号量集已经删除。</p>
<p>（6）EINTR：当睡眠时接收到其他信号。</p>
<p>（7）EINVAL：信号量集不存在,或者semid无效。</p>
<p>（8）ENOMEM：使用了SEM_UNDO，但无足够的内存创建所需的数据结构。</p>
<p>（9）ERANGE：信号量值超出范围。</p>
<p>sops为指向sembuf数组，定义所要进行的操作序列。下面是信号量操作举例。</p>
<p>struct sembuf sem_get={0,-1,IPC_NOWAIT}; /<em>将信号量对象中序号为0的信号量减1</em>/</p>
<p>struct sembuf sem_get={0,1,IPC_NOWAIT};  /<em>将信号量对象中序号为0的信号量加1</em>/</p>
<p>struct sembuf sem_get={0,0,0};           /<em>进程被阻塞，直到对应的信号量值为0</em>/</p>
<p>flag一般为0，若flag包含IPC_NOWAIT，则该操作为非阻塞操作。若flag包含SEM_UNDO，则当进程退出的时候会还原该进程的信号量操作，这个标志在某些情况下是很有用的，比如某进程做了P操作得到资源，但还没来得及做V操作时就异常退出了，此时，其他进程就只能都阻塞在P操作上，于是造成了死锁。若采取SEM_UNDO标志，就可以避免因为进程异常退出而造成的死锁。</p>
<h4 id="3-semctl函数原型"><a href="#3-semctl函数原型" class="headerlink" title="3.   semctl函数原型"></a>3.   semctl函数原型</h4><p>semctl (得到一个信号量集标识符或创建一个信号量集对象)</p>
<h5 id="所需头文件：-6"><a href="#所需头文件：-6" class="headerlink" title="所需头文件："></a>所需头文件：</h5><p><code>#include &lt;sys/types.h&gt;</code></p>
<p><code>#include &lt;sys/ipc.h&gt;</code></p>
<p><code>#include &lt;sys/sem.h&gt;</code></p>
<h5 id="函数说明：-6"><a href="#函数说明：-6" class="headerlink" title="函数说明："></a>函数说明：</h5><p>得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符。</p>
<h5 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h5><p>int semctl(int semid, int semnum, int cmd, union semun arg)</p>
<h5 id="函数传入值：-6"><a href="#函数传入值：-6" class="headerlink" title="函数传入值："></a>函数传入值：</h5><p>semid：信号量集标识符。</p>
<p>semnum：信号量集数组上的下标，表示某一个信号量。</p>
<p>cmd：见下文表。</p>
<p>arg：</p>
<p>union semun {</p>
<p>   short val;          /<em>SETVAL用的值</em>/</p>
<p>   struct semid_ds<em> buf; /</em>IPC_STAT、IPC_SET用的semid_ds结构*/</p>
<p>   unsigned short<em> array; /</em>SETALL、GETALL用的数组值*/</p>
<p>   struct seminfo <em>buf;   /</em>为控制IPC_INFO提供的缓存*/</p>
<p>  } arg;</p>
<h5 id="函数返回值：-6"><a href="#函数返回值：-6" class="headerlink" title="函数返回值："></a>函数返回值：</h5><p>（1）成功：大于或等于0，具体说明请参照下文表。</p>
<p>（2）出错：-1，错误原因存于error中。</p>
<h5 id="附加说明：-5"><a href="#附加说明：-5" class="headerlink" title="附加说明："></a>附加说明：</h5><p>semid_ds结构见信号量集内核结构定义。</p>
<h5 id="错误代码：-6"><a href="#错误代码：-6" class="headerlink" title="错误代码："></a>错误代码：</h5><p>（1）EACCESS：权限不够。</p>
<p>（2）EFAULT：arg指向的地址无效。</p>
<p>（3）EIDRM：信号量集已经删除。</p>
<p>（4）EINVAL：信号量集不存在，或者semid无效。</p>
<p>（5）EPERM：进程有效用户没有cmd的权限。</p>
<p>（6）ERANGE：信号量值超出范围。</p>
<p>表-semctl函数cmd形参说明表</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解   释</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPC_STAT</td>
<td>从信号量集上检索semid_ds结构，并存到semun联合体参数的成员buf的地址中</td>
</tr>
<tr>
<td>IPC_SET</td>
<td>设置一个信号量集合的semid_ds结构中ipc_perm域的值，并从semun的buf中取出值</td>
</tr>
<tr>
<td>IPC_RMID</td>
<td>从内核中删除信号量集合</td>
</tr>
<tr>
<td>GETALL</td>
<td>从信号量集合中获得所有信号量的值，并把其整数值存到semun联合体成员的一个指针数组中</td>
</tr>
<tr>
<td>GETNCNT</td>
<td>返回当前等待资源的进程个数</td>
</tr>
<tr>
<td>GETPID</td>
<td>返回最后一个执行系统调用semop()进程的PID</td>
</tr>
<tr>
<td>GETVAL</td>
<td>返回信号量集合内单个信号量的值</td>
</tr>
<tr>
<td>GETZCNT</td>
<td>返回当前等待100%资源利用的进程个数</td>
</tr>
<tr>
<td>SETALL</td>
<td>与GETALL正好相反</td>
</tr>
<tr>
<td>SETVAL</td>
<td>用联合体中val成员的值设置信号量集合中单个信号量的值</td>
</tr>
</tbody>
</table>
<h3 id="五、struct-sembuf的部分讲解"><a href="#五、struct-sembuf的部分讲解" class="headerlink" title="五、struct sembuf的部分讲解"></a>五、struct sembuf的部分讲解</h3><p><code>struct sembuf</code><br>{<br>  unsigned short int sem_num;   /<em> 信号量的序号从0~nsems-1 </em>/<br>  short int sem_op;            /<em> 对信号量的操作，&gt;0, 0, &lt;0 </em>/<br>  short int sem_flg;            /<em> 操作标识：0， IPC_WAIT, SEM_UNDO </em>/<br><code>};</code> </p>
<p><strong>sem_num</strong>标识信号量集中的第几个信号量，0表示第1个，1表示第2个，nsems - 1表示最后一个。</p>
<p><strong>sem_op</strong>标识对信号量的所进行的操作类型。对信号量的操作有三种类型：</p>
<ul>
<li>sem_op &gt; 0，对该信号量执行挂出操作，挂出的值由sem_op决定，系统会把sem_op的值加到该信号量的当前值semval（参考文章开头关于每个信号量结构的定义）上。如果sem_flag指定了SEM_UNDO（还原）标志，那么相应信号量的semadj值会减掉sem_op的值。下面会说明semadj的含义。</li>
<li>sem_op &lt; 0，对该信号量执行等待操作，当信号量的当前值semval &gt;= -sem_op时，semval减掉sem_op的绝对值，为该线程分配对应数目的资源。如果指定SEM_UNDO，相应信号量的semadj就加上sem_op的绝对值。当semval &lt; -sem_op时，相应信号量的semncnt就加1，调用线程被阻塞，直到semval &gt;= -sem_op，当此条件满足时，调用线程被唤醒，执行相应的分配操作，然后semncnt减去1.</li>
<li>sem_op = 0，表示调用者希望semval变为0。如果为0则立即返回，如果不为0，相应信号量的semzcnt加1，调用调用线程被阻塞。</li>
</ul>
<p><strong>sem_flag</strong>：信号量操作的属性标志，如果为0，表示正常操作，如果为IPC_WAIT，使对信号量的操作时非阻塞的。即指定了该标志，调用线程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将errno设置为EAGAIN。如果为SEM_UNDO，那么将维护进程对信号量的调整值，以便进程结束时恢复信号量的状态。</p>
<p>下面解释一下与单个信号量相关的几个值：</p>
<p><strong>semval</strong>：信号量的当前值，在文章开头信号量的结构中已提到。<em>**</em></p>
<p><strong>semncnt</strong>：等待semval变为大于当前值的线程数。在文章开头信号量的结构中已提到。</p>
<p><strong>semzcnt</strong>：等待semval变为0的线程数。在文章开头信号量的结构中已提到。</p>
<p><strong>semadj</strong>：指定信号量针对某个特定进程的调整值。只有sembuf结构的sem_flag指定为SEM_UNDO后，semadj才会随着sem_op而更新。<strong>讲简单一点：对某个进程，在指定SEM_UNDO后，对信号量semval值的修改都会反应到semadj上，当该进程终止的时候，内核会根据semadj的值，重新恢复信号量之前的值。</strong></p>
<h3 id="六、本次实验代码"><a href="#六、本次实验代码" class="headerlink" title="六、本次实验代码"></a>六、本次实验代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_MODE 0600</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_MODE 0600</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_FULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_EMPTY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUTEX 2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#if defined(__GNU_LIBRARY__) &amp;&amp; !defined(_SEM_SEMUN_UNDEFINED)</span></span><br><span class="line"><span class="comment">//	 union   semun   is   defined   by   including   &lt;sys/sem.h&gt;   </span></span><br><span class="line"><span class="comment">#else </span></span><br><span class="line"><span class="comment">//   according   to   X/OPEN   we   have   to   define   it   ourselves  </span></span><br><span class="line"><span class="comment">union semun&#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct semid_ds *buf;</span></span><br><span class="line"><span class="comment">	unsigned short *array;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">union semun su;//sem union，用于初始化信号量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">char</span> str[MAX_BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> num;  <span class="comment">//缓冲区里字母数量</span></span><br><span class="line">	<span class="keyword">int</span> is_empty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_CONSUMER = <span class="number">2</span>;<span class="comment">//消费者数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_PRODUCER = <span class="number">2</span>;<span class="comment">//生产者数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_BUFFER = <span class="number">10</span>;<span class="comment">//缓冲区容量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_WORKTIME = <span class="number">10</span>;<span class="comment">//工作次数</span></span><br><span class="line"><span class="keyword">int</span> shm_id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> sem_id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">pid_t</span> child;</span><br><span class="line"><span class="keyword">pid_t</span> parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到10以内的一个随机数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_random</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> digit;  </span><br><span class="line">    srand((<span class="keyword">unsigned</span>)(getpid() + time(<span class="literal">NULL</span>)));  </span><br><span class="line">    digit = rand() % <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">return</span> digit;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//得到A～Z的一个随机字母  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getRandChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> letter;  </span><br><span class="line">    srand((<span class="keyword">unsigned</span>)(getpid() + time(<span class="literal">NULL</span>)));  </span><br><span class="line">    letter = (<span class="keyword">char</span>)((rand() % <span class="number">26</span>) + <span class="string">'A'</span>);  </span><br><span class="line">    <span class="keyword">return</span> letter;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_id 表示信号量集合的 id</span></span><br><span class="line"><span class="comment">//sem_num 表示要处理的信号量在信号量集合中的索引</span></span><br><span class="line"><span class="comment">//P操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitSem</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sb</span>;</span></span><br><span class="line">	sb.sem_num = sem_num;</span><br><span class="line">	sb.sem_op = <span class="number">-1</span>;<span class="comment">//表示要把信号量减一</span></span><br><span class="line">	sb.sem_flg = SEM_UNDO;<span class="comment">//</span></span><br><span class="line">	<span class="comment">//第二个参数是 sembuf [] 类型的，表示数组</span></span><br><span class="line">	<span class="comment">//第三个参数表示 第二个参数代表的数组的大小</span></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id,&amp;sb,<span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"waitSem failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//V操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigSem</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sb</span>;</span></span><br><span class="line">	sb.sem_num = sem_num;</span><br><span class="line">	sb.sem_op = <span class="number">1</span>;</span><br><span class="line">	sb.sem_flg = SEM_UNDO;</span><br><span class="line">	<span class="comment">//第二个参数是 sembuf [] 类型的，表示数组</span></span><br><span class="line">	<span class="comment">//第三个参数表示 第二个参数代表的数组的大小</span></span><br><span class="line">	<span class="keyword">if</span>(semop(sem_id,&amp;sb,<span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"sigSem failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印进程运行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打印时间</span></span><br><span class="line">	<span class="keyword">time_t</span> now;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">timenow</span>;</span>         <span class="comment">//实例化tm结构指针</span></span><br><span class="line">	time(&amp;now);</span><br><span class="line">	timenow = localtime(&amp;now);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"执行时间： %s "</span>,asctime(timenow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shm_id = shmget(IPC_PRIVATE,MAX_BUFFER_SIZE,SHM_MODE);   <span class="comment">//申请共享内存</span></span><br><span class="line">	<span class="keyword">if</span>(shm_id &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">"create shared memory failed"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_buffer</span> *<span class="title">shmptr</span>;</span>  </span><br><span class="line">	shmptr = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//将申请的共享内存附加到申请通信的进程空间</span></span><br><span class="line">	<span class="keyword">if</span> (shmptr == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">        perror(<span class="string">"add buffer to using process space failed！\n"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((sem_id = semget(IPC_PRIVATE,<span class="number">3</span>,SEM_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;                  								<span class="comment">//创建三个信号量，SEM_EMPTY,SEM_FULL和MUTEX</span></span><br><span class="line">		perror(<span class="string">"create semaphore failed! \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id,SEM_FULL,SETVAL,<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;												<span class="comment">//将索引为0的信号量设置为0--&gt;SEM_FULL</span></span><br><span class="line">		perror(<span class="string">"sem set value error! \n"</span>);		</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id,SEM_EMPTY,SETVAL,<span class="number">10</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;												<span class="comment">//将索引为1的信号量设置为10--&gt;SEM_EMPTY</span></span><br><span class="line">	 	perror(<span class="string">"sem set value error! \n"</span>);</span><br><span class="line">	 	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(semctl(sem_id,MUTEX,SETVAL,<span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">	&#123;												<span class="comment">//将索引为3的信号量设置为1--&gt;MUTEX</span></span><br><span class="line">	 	perror(<span class="string">"sem set value error! \n"</span>);</span><br><span class="line">	 	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shmptr -&gt; head = <span class="number">0</span>;  </span><br><span class="line">    shmptr -&gt; tail = <span class="number">0</span>;  </span><br><span class="line">    shmptr -&gt; is_empty = <span class="number">1</span>;  </span><br><span class="line">    shmptr -&gt; num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_PRODUCER; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		parent = fork();</span><br><span class="line">		<span class="keyword">if</span>(parent &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"the fork failed"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(parent == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			shmptr = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//将申请的共享内存附加到申请通信的进程空间</span></span><br><span class="line">			<span class="keyword">if</span> (shmptr == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">			&#123;  </span><br><span class="line">        		perror(<span class="string">"add buffer to using process space failed！\n"</span>);  </span><br><span class="line">        		<span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    		&#125;  </span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N_WORKTIME; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				waitSem(sem_id, SEM_EMPTY);</span><br><span class="line">				waitSem(sem_id, MUTEX);</span><br><span class="line">				sleep(get_random()); </span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"我是第 %d 个生产者进程，PID = %d\n"</span>, i + <span class="number">1</span>, getpid());</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*生产产品*/</span></span><br><span class="line">				<span class="keyword">char</span> c = getRandChar();                                      <span class="comment">//随机获取字母</span></span><br><span class="line">				shmptr -&gt; str[shmptr-&gt;tail] = c;</span><br><span class="line">                shmptr -&gt; tail = (shmptr-&gt;tail + <span class="number">1</span>) % MAX_BUFFER_SIZE;  </span><br><span class="line">                shmptr -&gt; is_empty = <span class="number">0</span>;           <span class="comment">//写入新产品  </span></span><br><span class="line">				shmptr -&gt; num++;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*打印输出结果*/</span></span><br><span class="line">				printTime();              <span class="comment">//程序运行时间</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> p;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,shmptr -&gt; num);                   <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">				p = (shmptr-&gt;tail<span class="number">-1</span> &gt;= shmptr-&gt;head) ? (shmptr-&gt;tail<span class="number">-1</span>) : (shmptr-&gt;tail<span class="number">-1</span> + MAX_BUFFER_SIZE);  </span><br><span class="line">                <span class="keyword">for</span> (p; !(shmptr -&gt; is_empty) &amp;&amp; p &gt;= shmptr -&gt; head; p--)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, shmptr -&gt; str[p % MAX_BUFFER_SIZE]);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t 生产者 %d  放入 '%c'. \n"</span>, i + <span class="number">1</span>, c);  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">				fflush(<span class="built_in">stdout</span>);</span><br><span class="line">				sigSem(sem_id, MUTEX);</span><br><span class="line">				sigSem(sem_id, SEM_FULL);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将共享段与进程之间解除连接  </span></span><br><span class="line">            shmdt(shmptr);  </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_CONSUMER; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		child = fork();</span><br><span class="line">		<span class="keyword">if</span>(child &lt; <span class="number">0</span>)<span class="comment">//调用fork失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">"the fork failed"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">			shmptr = shmat(shm_id, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//将申请的共享内存附加到申请通信的进程空间</span></span><br><span class="line">			<span class="keyword">if</span> (shmptr == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">			&#123;  </span><br><span class="line">        		perror(<span class="string">"add buffer to using process space failed！\n"</span>);  </span><br><span class="line">        		<span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    		&#125; </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N_WORKTIME; j++)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				waitSem(sem_id, SEM_FULL);</span><br><span class="line">				waitSem(sem_id, MUTEX);</span><br><span class="line">				sleep(get_random()); </span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"我是第 %d 个消费者进程，PID = %d\n"</span>, i + <span class="number">1</span>, getpid());</span><br><span class="line">				<span class="comment">/*消费数据*/</span></span><br><span class="line">				<span class="keyword">char</span> lt = shmptr -&gt; str[shmptr -&gt; head];  </span><br><span class="line">                shmptr -&gt; head = (shmptr -&gt; head + <span class="number">1</span>) % MAX_BUFFER_SIZE;  </span><br><span class="line">                shmptr -&gt; is_empty = (shmptr-&gt;head == shmptr-&gt;tail);  <span class="comment">//</span></span><br><span class="line">				shmptr -&gt; num--;</span><br><span class="line">				<span class="comment">/*打印输出结果*/</span></span><br><span class="line">				printTime(); <span class="comment">//程序运行时间</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> p;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,shmptr -&gt; num);                   <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">				p = (shmptr -&gt; tail - <span class="number">1</span> &gt;= shmptr -&gt; head) ? (shmptr -&gt; tail<span class="number">-1</span>) : (shmptr -&gt; tail - <span class="number">1</span> + MAX_BUFFER_SIZE);  </span><br><span class="line">                <span class="keyword">for</span> (p; !(shmptr -&gt; is_empty) &amp;&amp; p &gt;= shmptr -&gt; head; p--)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, shmptr -&gt; str[p % MAX_BUFFER_SIZE]);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t 消费者 %d  取出 '%c'. \n"</span>, i + <span class="number">1</span>, lt);  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">				fflush(<span class="built_in">stdout</span>);</span><br><span class="line">				sigSem(sem_id,MUTEX);</span><br><span class="line">				sigSem(sem_id,SEM_EMPTY);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//将共享段与进程之间解除连接  </span></span><br><span class="line">        	shmdt(shmptr);  </span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//主进程最后退出  </span></span><br><span class="line">    <span class="keyword">while</span> (wait(<span class="number">0</span>) != <span class="number">-1</span>);  </span><br><span class="line">    <span class="comment">//将共享段与进程之间解除连接  </span></span><br><span class="line">    shmdt(shmptr);  </span><br><span class="line">    <span class="comment">//对共享内存区执行控制操作  </span></span><br><span class="line">    shmctl(shm_id,IPC_RMID,<span class="number">0</span>);<span class="comment">//当cmd为IPC_RMID时，删除该共享段  </span></span><br><span class="line">    shmctl(sem_id,IPC_RMID,<span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主进程运行结束！\n"</span>);  </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、利用多线程实现本实验"><a href="#七、利用多线程实现本实验" class="headerlink" title="七、利用多线程实现本实验"></a>七、利用多线程实现本实验</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*信号量*/</span></span><br><span class="line"><span class="comment">//空的信号量和满的信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> empty_sem, full_sem;   </span><br><span class="line"><span class="comment">//静态创建条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> full = PTHREAD_COND_INITIALIZER;        <span class="comment">//满的变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;       <span class="comment">//空的变量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;      <span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFERNUM 10    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> production[BUFFERNUM];  <span class="comment">//产品</span></span><br><span class="line">	<span class="keyword">int</span> front, rear;             <span class="comment">//头指针和尾指针</span></span><br><span class="line">	<span class="keyword">int</span> num;                     <span class="comment">//缓冲区里面字母数量        </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出设计者信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDesign</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   ┃            生产者-消费者问题实现                 ┃\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机产生生产字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getRandChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = rand()%<span class="number">26</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">'a'</span>+temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印进程运行结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打印时间</span></span><br><span class="line">	<span class="keyword">time_t</span> now;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">timenow</span>;</span>         <span class="comment">//实例化tm结构指针</span></span><br><span class="line">	time(&amp;now);</span><br><span class="line">	timenow = localtime(&amp;now);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"执行时间： %s "</span>,asctime(timenow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> *<span class="title">q</span>;</span></span><br><span class="line">	q = (struct Buffer_Queue *) arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);       </span><br><span class="line">		<span class="keyword">while</span> (q-&gt;num == BUFFERNUM)    <span class="comment">//缓冲区已经满了，等待</span></span><br><span class="line">		&#123;            </span><br><span class="line">			pthread_cond_wait(&amp;full, &amp;lock);</span><br><span class="line">		&#125;</span><br><span class="line">		sem_wait(&amp;empty_sem);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*生产产品*/</span></span><br><span class="line">		<span class="keyword">char</span> c = getRandChar();                                      <span class="comment">//随机获取字母</span></span><br><span class="line">		q-&gt;rear = (q-&gt;rear + <span class="number">1</span>) % BUFFERNUM;                         <span class="comment">//计算新的尾指针   </span></span><br><span class="line">		q-&gt;production[q-&gt;rear] = c;                                  <span class="comment">//写入新产品</span></span><br><span class="line">		q-&gt;num++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*打印输出结果*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">		printTime();              <span class="comment">//程序运行时间</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,q-&gt;num);                  <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">		<span class="keyword">if</span>(q-&gt;front &lt; q-&gt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt; BUFFERNUM; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n当前执行的进程：生产者1\n"</span>);   <span class="comment">//打印当前执行的进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"产生的数据：%c\n"</span>,c);      <span class="comment">//打印产生或消费的数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">		sem_post(&amp;full_sem);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (q-&gt;num == <span class="number">1</span>) &#123;</span><br><span class="line">			pthread_cond_signal(&amp;empty);    </span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">		sleep(rand() % <span class="number">2</span>);            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> *<span class="title">q</span>;</span></span><br><span class="line">	q = (struct Buffer_Queue *) arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);       </span><br><span class="line">		<span class="keyword">while</span> (q-&gt;num == BUFFERNUM)    <span class="comment">//缓冲区已经满了，等待</span></span><br><span class="line">		&#123;            </span><br><span class="line">			pthread_cond_wait(&amp;full, &amp;lock);</span><br><span class="line">		&#125;</span><br><span class="line">		sem_wait(&amp;empty_sem);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*生产产品*/</span></span><br><span class="line">		<span class="keyword">char</span> c = getRandChar();                                      <span class="comment">//随机获取字母</span></span><br><span class="line">		q-&gt;rear = (q-&gt;rear + <span class="number">1</span>) % BUFFERNUM;                         <span class="comment">//计算新的尾指针   </span></span><br><span class="line">		q-&gt;production[q-&gt;rear] = c;                                  <span class="comment">//写入新产品  </span></span><br><span class="line">		q-&gt;num++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*打印输出结果*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">		printTime();              <span class="comment">//程序运行时间</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,q-&gt;num);                   <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">		<span class="keyword">if</span>(q-&gt;front &lt; q-&gt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt; BUFFERNUM; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n当前执行的进程：生产者2\n"</span>);   <span class="comment">//打印当前执行的进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"产生的数据：%c\n"</span>,c);      <span class="comment">//打印产生或消费的数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">		sem_post(&amp;full_sem);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (q-&gt;num == <span class="number">1</span>) &#123;</span><br><span class="line">			pthread_cond_signal(&amp;empty);    </span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">		sleep(rand() % <span class="number">2</span>);            </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> *<span class="title">q</span>;</span></span><br><span class="line">	q = (struct Buffer_Queue *) arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);        </span><br><span class="line">		<span class="keyword">while</span> (q-&gt;num == <span class="number">0</span>)           <span class="comment">//缓冲区已经空了，等待</span></span><br><span class="line">		&#123;        </span><br><span class="line">			pthread_cond_wait(&amp;empty, &amp;lock);</span><br><span class="line">		&#125;</span><br><span class="line">		sem_wait(&amp;full_sem);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*消费产品*/</span></span><br><span class="line">		q-&gt;front = (q-&gt;front + <span class="number">1</span>) % BUFFERNUM;    <span class="comment">//计算新的头指针</span></span><br><span class="line">		<span class="keyword">char</span> c = q-&gt;production[q-&gt;front];         <span class="comment">//消费产品</span></span><br><span class="line">		q-&gt;production[q-&gt;front] = <span class="string">' '</span>;            <span class="comment">//</span></span><br><span class="line">		q-&gt;num--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*打印输出结果*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">		printTime();              <span class="comment">//程序运行时间</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,q-&gt;num);                   <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">		<span class="keyword">if</span>(q-&gt;front &lt; q-&gt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt; BUFFERNUM; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n当前执行的进程：消费者1\n"</span>);   <span class="comment">//打印当前执行的进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"消耗的数据：%c\n"</span>,c);      <span class="comment">//打印产生或消费的数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		sem_post(&amp;empty_sem);</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;num == BUFFERNUM - <span class="number">1</span>) &#123;</span><br><span class="line">			pthread_cond_signal(&amp;full);</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line">		sleep(rand() % <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> *<span class="title">q</span>;</span></span><br><span class="line">	q = (struct Buffer_Queue *) arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);        </span><br><span class="line">		<span class="keyword">while</span> (q-&gt;num == <span class="number">0</span>)           <span class="comment">//缓冲区已经空了，等待</span></span><br><span class="line">		&#123;        </span><br><span class="line">			pthread_cond_wait(&amp;empty, &amp;lock);</span><br><span class="line">		&#125;</span><br><span class="line">		sem_wait(&amp;full_sem);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*消费产品*/</span></span><br><span class="line">		q-&gt;front = (q-&gt;front + <span class="number">1</span>) % BUFFERNUM;    <span class="comment">//计算新的头指针</span></span><br><span class="line">		<span class="keyword">char</span> c = q-&gt;production[q-&gt;front];         <span class="comment">//消费产品</span></span><br><span class="line">		q-&gt;production[q-&gt;front] = <span class="string">' '</span>;            <span class="comment">//</span></span><br><span class="line">		q-&gt;num--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*打印输出结果*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line">		printTime();              <span class="comment">//程序运行时间</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"缓冲区数据（%d个）："</span>,q-&gt;num);                   <span class="comment">//打印缓冲区中的数据</span></span><br><span class="line">		<span class="keyword">if</span>(q-&gt;front &lt; q-&gt;rear)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = q-&gt;front; i &lt; BUFFERNUM; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= q-&gt;rear; i++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>,q-&gt;production[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n当前执行的进程：消费者1\n"</span>);   <span class="comment">//打印当前执行的进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"消耗的数据：%c\n"</span>,c);      <span class="comment">//打印产生或消费的数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-------------------------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		sem_post(&amp;empty_sem);</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;num == BUFFERNUM - <span class="number">1</span>) &#123;</span><br><span class="line">			pthread_cond_signal(&amp;full);</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line">		sleep(rand() % <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出设计者</span></span><br><span class="line">	printDesign();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建缓冲区*/</span></span><br><span class="line">	<span class="comment">//定义</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Buffer_Queue</span> *<span class="title">q</span>;</span></span><br><span class="line">	q = (struct Buffer_Queue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Buffer_Queue));</span><br><span class="line">	<span class="comment">//初始化队列</span></span><br><span class="line">	q-&gt;front = q-&gt;rear = BUFFERNUM - <span class="number">1</span>;</span><br><span class="line">	q-&gt;num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*执行进程*/</span></span><br><span class="line">	<span class="comment">//定义四个线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> pid1, cid1, pid2, cid2;</span><br><span class="line">	<span class="comment">//初始化信号量</span></span><br><span class="line">	sem_init(&amp;empty_sem, <span class="number">0</span>, BUFFERNUM);   </span><br><span class="line">	sem_init(&amp;full_sem, <span class="number">0</span>, <span class="number">0</span>);   </span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	pthread_create(&amp;pid1, <span class="literal">NULL</span>, producer1, (<span class="keyword">void</span> *) q);</span><br><span class="line">	pthread_create(&amp;cid1, <span class="literal">NULL</span>, consumer1, (<span class="keyword">void</span> *) q);</span><br><span class="line">	pthread_create(&amp;pid2, <span class="literal">NULL</span>, producer2, (<span class="keyword">void</span> *) q);</span><br><span class="line">	pthread_create(&amp;cid2, <span class="literal">NULL</span>, consumer2, (<span class="keyword">void</span> *) q);</span><br><span class="line">	<span class="comment">//销毁线程</span></span><br><span class="line">	pthread_join(pid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(cid1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pid2, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(cid2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//销毁信号量</span></span><br><span class="line">	sem_destroy(&amp;empty_sem);</span><br><span class="line">	sem_destroy(&amp;full_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'abigale-1';
var disqus_identifier = '2018/01/24/Producer&amp;Consumer_Linux/';
var disqus_title = 'Linux下利用信号量函数和共享内存函数和C语言实现生产者消费者问题';
var disqus_url = 'http://yoursite.com/2018/01/24/Producer&amp;Consumer_Linux/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:857911790@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="http://weibo.com/weibo.com" target="_blank"><i class="fa fa-weibo"></i></a><a href="https://github.com/o1zhs" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">zhs</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>